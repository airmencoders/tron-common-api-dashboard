/* tslint:disable */
/* eslint-disable */
/**
 * TRON Common API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AppClientSummaryDtoResponseWrapper } from '../models';
// @ts-ignore
import { DocumentMobileDtoResponseWrapper } from '../models';
// @ts-ignore
import { DocumentSpaceAppClientMemberRequestDto } from '../models';
// @ts-ignore
import { DocumentSpaceAppClientResponseDtoWrapper } from '../models';
// @ts-ignore
import { DocumentSpaceArchiveItemsDto } from '../models';
// @ts-ignore
import { DocumentSpaceCreateFolderDto } from '../models';
// @ts-ignore
import { DocumentSpaceDashboardMemberRequestDto } from '../models';
// @ts-ignore
import { DocumentSpaceDashboardMemberResponseDtoResponseWrapper } from '../models';
// @ts-ignore
import { DocumentSpaceFolderInfoDto } from '../models';
// @ts-ignore
import { DocumentSpacePathItemsDto } from '../models';
// @ts-ignore
import { DocumentSpacePrivilegeDtoResponseWrapper } from '../models';
// @ts-ignore
import { DocumentSpaceRenameFileDto } from '../models';
// @ts-ignore
import { DocumentSpaceRenameFolderDto } from '../models';
// @ts-ignore
import { DocumentSpaceRequestDto } from '../models';
// @ts-ignore
import { DocumentSpaceResponseDto } from '../models';
// @ts-ignore
import { DocumentSpaceResponseDtoResponseWrapper } from '../models';
// @ts-ignore
import { DocumentSpaceSearchDto } from '../models';
// @ts-ignore
import { DocumentSpaceUnArchiveItemsDto } from '../models';
// @ts-ignore
import { DocumentSpaceUserCollectionResponseDtoWrapper } from '../models';
// @ts-ignore
import { ExceptionResponse } from '../models';
// @ts-ignore
import { FilePathSpec } from '../models';
// @ts-ignore
import { FilePathSpecWrapper } from '../models';
// @ts-ignore
import { RecentDocumentDtoResponseWrapper } from '../models';
// @ts-ignore
import { S3PaginationDto } from '../models';
/**
 * DocumentSpaceControllerApi - axios parameter creator
 * @export
 */
export const DocumentSpaceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds an App Client to a Document Space with specified privileges
         * @summary Adds an App Client to a Document Space
         * @param {string} id 
         * @param {DocumentSpaceAppClientMemberRequestDto} documentSpaceAppClientMemberRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAppClientToDocumentSpace: async (id: string, documentSpaceAppClientMemberRequestDto: DocumentSpaceAppClientMemberRequestDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addAppClientToDocumentSpace.');
            }
            // verify required parameter 'documentSpaceAppClientMemberRequestDto' is not null or undefined
            if (documentSpaceAppClientMemberRequestDto === null || documentSpaceAppClientMemberRequestDto === undefined) {
                throw new RequiredError('documentSpaceAppClientMemberRequestDto','Required parameter documentSpaceAppClientMemberRequestDto was null or undefined when calling addAppClientToDocumentSpace.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/app-client`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof documentSpaceAppClientMemberRequestDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(documentSpaceAppClientMemberRequestDto !== undefined ? documentSpaceAppClientMemberRequestDto : {})
                : (documentSpaceAppClientMemberRequestDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a new entry to a favorites collection. If no collection exists, it also creates one.
         * @param {string} id 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntityToFavorites: async (id: string, entryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addEntityToFavorites.');
            }
            // verify required parameter 'entryId' is not null or undefined
            if (entryId === null || entryId === undefined) {
                throw new RequiredError('entryId','Required parameter entryId was null or undefined when calling addEntityToFavorites.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/collection/favorite/{entryId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"entryId"}}`, encodeURIComponent(String(entryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a new entry provided with a path to a favorites collection. If no collection exists, it also creates one.
         * @param {string} id 
         * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPathEntityToFavorites: async (id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addPathEntityToFavorites.');
            }
            // verify required parameter 'documentSpacePathItemsDto' is not null or undefined
            if (documentSpacePathItemsDto === null || documentSpacePathItemsDto === undefined) {
                throw new RequiredError('documentSpacePathItemsDto','Required parameter documentSpacePathItemsDto was null or undefined when calling addPathEntityToFavorites.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/collection/favorite/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof documentSpacePathItemsDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(documentSpacePathItemsDto !== undefined ? documentSpacePathItemsDto : {})
                : (documentSpacePathItemsDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a user to a Document Space with specified privileges
         * @summary Adds a user to a Document Space
         * @param {string} id 
         * @param {DocumentSpaceDashboardMemberRequestDto} documentSpaceDashboardMemberRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToDocumentSpace: async (id: string, documentSpaceDashboardMemberRequestDto: DocumentSpaceDashboardMemberRequestDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addUserToDocumentSpace.');
            }
            // verify required parameter 'documentSpaceDashboardMemberRequestDto' is not null or undefined
            if (documentSpaceDashboardMemberRequestDto === null || documentSpaceDashboardMemberRequestDto === undefined) {
                throw new RequiredError('documentSpaceDashboardMemberRequestDto','Required parameter documentSpaceDashboardMemberRequestDto was null or undefined when calling addUserToDocumentSpace.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof documentSpaceDashboardMemberRequestDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(documentSpaceDashboardMemberRequestDto !== undefined ? documentSpaceDashboardMemberRequestDto : {})
                : (documentSpaceDashboardMemberRequestDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Archives (soft-delete) selected files/folder from a Document Space
         * @summary Archives selected item(s) from a Document Space
         * @param {string} id 
         * @param {DocumentSpaceArchiveItemsDto} documentSpaceArchiveItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveItems: async (id: string, documentSpaceArchiveItemsDto: DocumentSpaceArchiveItemsDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling archiveItems.');
            }
            // verify required parameter 'documentSpaceArchiveItemsDto' is not null or undefined
            if (documentSpaceArchiveItemsDto === null || documentSpaceArchiveItemsDto === undefined) {
                throw new RequiredError('documentSpaceArchiveItemsDto','Required parameter documentSpaceArchiveItemsDto was null or undefined when calling archiveItems.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/archive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof documentSpaceArchiveItemsDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(documentSpaceArchiveItemsDto !== undefined ? documentSpaceArchiveItemsDto : {})
                : (documentSpaceArchiveItemsDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds multiple users via a csv to a Document Space with specified privileges. Returns a list of any errors encountered.
         * @summary Adds multiple users to a Document Space
         * @param {string} id 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchAddUserToDocumentSpace: async (id: string, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling batchAddUserToDocumentSpace.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/batchUsers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Copies files either within the same space (if sourceSpaceId is equal to the destination space \'id\').  If copying cross-space, then the user must have READ privileges at a minimum on the source space ID - and obviously needs at least WRITE at the destination
         * @summary Copies file(s)/folders(s) from one location in a document space to another within same space.
         * @param {string} id Destination Space UUID
         * @param {{ [key: string]: string; }} requestBody 
         * @param {string} [sourceSpaceId] UUID of the source space (if cross space copying) - otherwise uses current space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyFiles: async (id: string, requestBody: { [key: string]: string; }, sourceSpaceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling copyFiles.');
            }
            // verify required parameter 'requestBody' is not null or undefined
            if (requestBody === null || requestBody === undefined) {
                throw new RequiredError('requestBody','Required parameter requestBody was null or undefined when calling copyFiles.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/copy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sourceSpaceId !== undefined) {
                localVarQueryParameter['sourceSpaceId'] = sourceSpaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof requestBody !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(requestBody !== undefined ? requestBody : {})
                : (requestBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new folder within a Document Space
         * @param {string} id 
         * @param {DocumentSpaceCreateFolderDto} documentSpaceCreateFolderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder: async (id: string, documentSpaceCreateFolderDto: DocumentSpaceCreateFolderDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createFolder.');
            }
            // verify required parameter 'documentSpaceCreateFolderDto' is not null or undefined
            if (documentSpaceCreateFolderDto === null || documentSpaceCreateFolderDto === undefined) {
                throw new RequiredError('documentSpaceCreateFolderDto','Required parameter documentSpaceCreateFolderDto was null or undefined when calling createFolder.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/folders`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof documentSpaceCreateFolderDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(documentSpaceCreateFolderDto !== undefined ? documentSpaceCreateFolderDto : {})
                : (documentSpaceCreateFolderDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Document Space
         * @summary Creates a Document Space
         * @param {DocumentSpaceRequestDto} documentSpaceRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpace: async (documentSpaceRequestDto: DocumentSpaceRequestDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentSpaceRequestDto' is not null or undefined
            if (documentSpaceRequestDto === null || documentSpaceRequestDto === undefined) {
                throw new RequiredError('documentSpaceRequestDto','Required parameter documentSpaceRequestDto was null or undefined when calling createSpace.');
            }
            const localVarPath = `/v2/document-space/spaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof documentSpaceRequestDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(documentSpaceRequestDto !== undefined ? documentSpaceRequestDto : {})
                : (documentSpaceRequestDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Archive a single file/folder from a Document Space by parent folder id and item name
         * @summary Archive a file/folder from a Document Space
         * @param {string} id 
         * @param {string} parentFolderId 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArchiveItemBySpaceAndParent: async (id: string, parentFolderId: string, filename: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteArchiveItemBySpaceAndParent.');
            }
            // verify required parameter 'parentFolderId' is not null or undefined
            if (parentFolderId === null || parentFolderId === undefined) {
                throw new RequiredError('parentFolderId','Required parameter parentFolderId was null or undefined when calling deleteArchiveItemBySpaceAndParent.');
            }
            // verify required parameter 'filename' is not null or undefined
            if (filename === null || filename === undefined) {
                throw new RequiredError('filename','Required parameter filename was null or undefined when calling deleteArchiveItemBySpaceAndParent.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/folder/{parentFolderId}/file/{filename}/archive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parentFolderId"}}`, encodeURIComponent(String(parentFolderId)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a single file from a Document Space by parent folder id and filename
         * @summary Delete from a Document Space
         * @param {string} id 
         * @param {string} parentFolderId 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileBySpaceAndParent: async (id: string, parentFolderId: string, filename: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteFileBySpaceAndParent.');
            }
            // verify required parameter 'parentFolderId' is not null or undefined
            if (parentFolderId === null || parentFolderId === undefined) {
                throw new RequiredError('parentFolderId','Required parameter parentFolderId was null or undefined when calling deleteFileBySpaceAndParent.');
            }
            // verify required parameter 'filename' is not null or undefined
            if (filename === null || filename === undefined) {
                throw new RequiredError('filename','Required parameter filename was null or undefined when calling deleteFileBySpaceAndParent.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/folder/{parentFolderId}/file/{filename}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parentFolderId"}}`, encodeURIComponent(String(parentFolderId)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes selected files/folder from a Document Space
         * @summary Deletes selected item(s) from a Document Space
         * @param {string} id 
         * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItems: async (id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteItems.');
            }
            // verify required parameter 'documentSpacePathItemsDto' is not null or undefined
            if (documentSpacePathItemsDto === null || documentSpacePathItemsDto === undefined) {
                throw new RequiredError('documentSpacePathItemsDto','Required parameter documentSpacePathItemsDto was null or undefined when calling deleteItems.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/delete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof documentSpacePathItemsDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(documentSpacePathItemsDto !== undefined ? documentSpacePathItemsDto : {})
                : (documentSpacePathItemsDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Document Space
         * @summary Deletes a Document Space
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpace: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteSpace.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads all files from a space as a zip file
         * @summary Download all files from a Document Space
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAllFilesInSpace: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling downloadAllFilesInSpace.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/files/download/all`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Download a single file from a Document Space
         * @summary Download from a Document Space
         * @param {string} id 
         * @param {boolean} [download] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (id: string, download?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling downloadFile.');
            }
            const localVarPath = `/v2/document-space/space/{id}/**`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Download a single file (folders not allowed) from a Document Space by parent folder id and filename
         * @summary Download a file from a Document Space
         * @param {string} id 
         * @param {string} parentFolderId 
         * @param {string} filename 
         * @param {boolean} [download] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFileBySpaceAndParent: async (id: string, parentFolderId: string, filename: string, download?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling downloadFileBySpaceAndParent.');
            }
            // verify required parameter 'parentFolderId' is not null or undefined
            if (parentFolderId === null || parentFolderId === undefined) {
                throw new RequiredError('parentFolderId','Required parameter parentFolderId was null or undefined when calling downloadFileBySpaceAndParent.');
            }
            // verify required parameter 'filename' is not null or undefined
            if (filename === null || filename === undefined) {
                throw new RequiredError('filename','Required parameter filename was null or undefined when calling downloadFileBySpaceAndParent.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/folder/{parentFolderId}/file/{filename}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parentFolderId"}}`, encodeURIComponent(String(parentFolderId)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads multiple files from the same folder into a zip file
         * @summary Download chosen files from a chosen Document Space folder
         * @param {string} id 
         * @param {Set<string>} files 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFiles: async (id: string, files: Set<string>, path?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling downloadFiles.');
            }
            // verify required parameter 'files' is not null or undefined
            if (files === null || files === undefined) {
                throw new RequiredError('files','Required parameter files was null or undefined when calling downloadFiles.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/files/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (files) {
                localVarQueryParameter['files'] = files;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists folders and files that are archived -folders/sub-folders cannot be navigated into while in archived status - just folder name is shown
         * @summary List folders and files that are in Archived status
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dumpArchivedContents: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling dumpArchivedContents.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/archived/contents`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists folders and files contained within given folder path - one level deep (does not recurse into any sub-folders)
         * @summary List folders and files at given path
         * @param {string} id 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dumpContentsAtPath: async (id: string, path?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling dumpContentsAtPath.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/contents`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves all archived files for the requesting user for spaces they have access to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArchivedFilesForAuthUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/document-space/spaces/archived`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the App Clients that can access a space and their privileges
         * @summary Gets the App Clients that can access a given Document Space
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppClientUsersForDocumentSpace: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAppClientUsersForDocumentSpace.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/app-clients`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * The list includes those that are not associated currently with given space
         * @summary Gets list of App Clients that are available to assignment to given doc space
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppClientsForAssignmentToDocumentSpace: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAppClientsForAssignmentToDocumentSpace.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/available-app-clients`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets members for a Document Space. Pagination enabled.
         * @summary Gets the members for a Document Space
         * @param {string} id 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardUsersForDocumentSpace: async (id: string, page?: number, size?: number, sort?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDashboardUsersForDocumentSpace.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/users/dashboard`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets path of entryId and document space id.
         * @param {string} id 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentSpaceEntryPath: async (id: string, entryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDocumentSpaceEntryPath.');
            }
            // verify required parameter 'entryId' is not null or undefined
            if (entryId === null || entryId === undefined) {
                throw new RequiredError('entryId','Required parameter entryId was null or undefined when calling getDocumentSpaceEntryPath.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/path/{entryId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"entryId"}}`, encodeURIComponent(String(entryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets entries from a favorites collection. If no collection exists, returns empty list.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavorites: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getFavorites.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/collection/favorite`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a folder\'s total size
         * @param {string} id 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderSize: async (id: string, path?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getFolderSize.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/folder-size`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves files from all spaces that the authenticated user has recently uploaded
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentlyUploadedFilesByAuthenticatedUser: async (page?: number, size?: number, sort?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/document-space/spaces/files/recently-uploaded`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requester must have at least READ access to provided Space.
         * @summary Gets provided space\'s recently uploaded files/updated files activity
         * @param {string} id Space UUID
         * @param {string} [date] ISO UTC date/time to search from looking back
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentsForSpace: async (id: string, date?: string, page?: number, size?: number, sort?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRecentsForSpace.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/recents`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString() :
                    date;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the Document Space privileges of the requesting user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSelfDashboardUserPrivilegesForDocumentSpace: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSelfDashboardUserPrivilegesForDocumentSpace.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/users/dashboard/privileges/self`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves all document spaces for the requesting user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpaces: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/document-space/spaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets files from a space. This is not a download
         * @summary Retrieves files from a space
         * @param {string} id 
         * @param {string} [continuation] the continuation token
         * @param {number} [limit] page limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listObjects: async (id: string, continuation?: string, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listObjects.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/files`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (continuation !== undefined) {
                localVarQueryParameter['continuation'] = continuation;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Moves files either within the same space (if sourceSpaceId is equal to the destination space \'id\').  If moving cross-space, then the user must have READ privileges at a minimum on the source space ID - and obviously needs at least WRITE at the destination
         * @summary Moves file(s)/folders(s) from one location in a document space to another within same space.
         * @param {string} id UUID of the destination space
         * @param {{ [key: string]: string; }} requestBody 
         * @param {string} [sourceSpaceId] UUID of the source space (if cross space moving) - otherwise uses current space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFiles: async (id: string, requestBody: { [key: string]: string; }, sourceSpaceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling moveFiles.');
            }
            // verify required parameter 'requestBody' is not null or undefined
            if (requestBody === null || requestBody === undefined) {
                throw new RequiredError('requestBody','Required parameter requestBody was null or undefined when calling moveFiles.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/move`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sourceSpaceId !== undefined) {
                localVarQueryParameter['sourceSpaceId'] = sourceSpaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof requestBody !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(requestBody !== undefined ? requestBody : {})
                : (requestBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets the default Document Space privileges of the requesting user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSelfDocumentSpaceDefault: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling patchSelfDocumentSpaceDefault.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/user/default`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes App Client(s) from a Document Space and their privileges
         * @summary Removes one or more App Client(s) from a Document Space
         * @param {string} id 
         * @param {string} appClientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAppClientFromDocumentSpace: async (id: string, appClientId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling removeAppClientFromDocumentSpace.');
            }
            // verify required parameter 'appClientId' is not null or undefined
            if (appClientId === null || appClientId === undefined) {
                throw new RequiredError('appClientId','Required parameter appClientId was null or undefined when calling removeAppClientFromDocumentSpace.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/app-client`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (appClientId !== undefined) {
                localVarQueryParameter['appClientId'] = appClientId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes an entry from a favorites collection.
         * @param {string} id 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEntityFromFavorites: async (id: string, entryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling removeEntityFromFavorites.');
            }
            // verify required parameter 'entryId' is not null or undefined
            if (entryId === null || entryId === undefined) {
                throw new RequiredError('entryId','Required parameter entryId was null or undefined when calling removeEntityFromFavorites.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/collection/favorite/{entryId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"entryId"}}`, encodeURIComponent(String(entryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes an entry provided with a path from a favorites collection.
         * @param {string} id 
         * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePathEntityFromFavorites: async (id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling removePathEntityFromFavorites.');
            }
            // verify required parameter 'documentSpacePathItemsDto' is not null or undefined
            if (documentSpacePathItemsDto === null || documentSpacePathItemsDto === undefined) {
                throw new RequiredError('documentSpacePathItemsDto','Required parameter documentSpacePathItemsDto was null or undefined when calling removePathEntityFromFavorites.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/collection/favorite/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof documentSpacePathItemsDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(documentSpacePathItemsDto !== undefined ? documentSpacePathItemsDto : {})
                : (documentSpacePathItemsDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes Dashboard Users from a Document Space and their privileges
         * @summary Removes one or more Dashboard User members from a Document Space
         * @param {string} id 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromDocumentSpace: async (id: string, requestBody: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling removeUserFromDocumentSpace.');
            }
            // verify required parameter 'requestBody' is not null or undefined
            if (requestBody === null || requestBody === undefined) {
                throw new RequiredError('requestBody','Required parameter requestBody was null or undefined when calling removeUserFromDocumentSpace.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/users/dashboard`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof requestBody !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(requestBody !== undefined ? requestBody : {})
                : (requestBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Renames a file
         * @param {string} id 
         * @param {DocumentSpaceRenameFileDto} documentSpaceRenameFileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameFile: async (id: string, documentSpaceRenameFileDto: DocumentSpaceRenameFileDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling renameFile.');
            }
            // verify required parameter 'documentSpaceRenameFileDto' is not null or undefined
            if (documentSpaceRenameFileDto === null || documentSpaceRenameFileDto === undefined) {
                throw new RequiredError('documentSpaceRenameFileDto','Required parameter documentSpaceRenameFileDto was null or undefined when calling renameFile.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/files/rename`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof documentSpaceRenameFileDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(documentSpaceRenameFileDto !== undefined ? documentSpaceRenameFileDto : {})
                : (documentSpaceRenameFileDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Renames a folder at a given path
         * @param {string} id 
         * @param {DocumentSpaceRenameFolderDto} documentSpaceRenameFolderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameFolder: async (id: string, documentSpaceRenameFolderDto: DocumentSpaceRenameFolderDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling renameFolder.');
            }
            // verify required parameter 'documentSpaceRenameFolderDto' is not null or undefined
            if (documentSpaceRenameFolderDto === null || documentSpaceRenameFolderDto === undefined) {
                throw new RequiredError('documentSpaceRenameFolderDto','Required parameter documentSpaceRenameFolderDto was null or undefined when calling renameFolder.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/folders`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof documentSpaceRenameFolderDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(documentSpaceRenameFolderDto !== undefined ? documentSpaceRenameFolderDto : {})
                : (documentSpaceRenameFolderDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requester must have at least READ access to provided Space.  Query is case-insensitive and is treated like a filename that \'contains\'...
         * @summary Search a document space for a filename or part of a filename
         * @param {string} id Space UUID
         * @param {DocumentSpaceSearchDto} documentSpaceSearchDto 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocumentSpace: async (id: string, documentSpaceSearchDto: DocumentSpaceSearchDto, page?: number, size?: number, sort?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling searchDocumentSpace.');
            }
            // verify required parameter 'documentSpaceSearchDto' is not null or undefined
            if (documentSpaceSearchDto === null || documentSpaceSearchDto === undefined) {
                throw new RequiredError('documentSpaceSearchDto','Required parameter documentSpaceSearchDto was null or undefined when calling searchDocumentSpace.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/search`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof documentSpaceSearchDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(documentSpaceSearchDto !== undefined ? documentSpaceSearchDto : {})
                : (documentSpaceSearchDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Similar to usage of the Unix stat command
         * @summary Get info about a file(s) at given path
         * @param {string} id 
         * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statElementsAtPath: async (id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling statElementsAtPath.');
            }
            // verify required parameter 'documentSpacePathItemsDto' is not null or undefined
            if (documentSpacePathItemsDto === null || documentSpacePathItemsDto === undefined) {
                throw new RequiredError('documentSpacePathItemsDto','Required parameter documentSpacePathItemsDto was null or undefined when calling statElementsAtPath.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/stat`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof documentSpacePathItemsDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(documentSpacePathItemsDto !== undefined ? documentSpacePathItemsDto : {})
                : (documentSpacePathItemsDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Un-archives selected files/folder from a Document Space
         * @summary Un-archives selected item(s) from a Document Space
         * @param {string} id 
         * @param {DocumentSpaceUnArchiveItemsDto} documentSpaceUnArchiveItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unArchiveItems: async (id: string, documentSpaceUnArchiveItemsDto: DocumentSpaceUnArchiveItemsDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unArchiveItems.');
            }
            // verify required parameter 'documentSpaceUnArchiveItemsDto' is not null or undefined
            if (documentSpaceUnArchiveItemsDto === null || documentSpaceUnArchiveItemsDto === undefined) {
                throw new RequiredError('documentSpaceUnArchiveItemsDto','Required parameter documentSpaceUnArchiveItemsDto was null or undefined when calling unArchiveItems.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/unarchive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof documentSpaceUnArchiveItemsDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(documentSpaceUnArchiveItemsDto !== undefined ? documentSpaceUnArchiveItemsDto : {})
                : (documentSpaceUnArchiveItemsDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a file to a Document Space. API will attempt to use the `Last-Modified` date (formatted as long epoch date) in the header in order to keep the uploaded copy\'s modified date to track its origin.  If that header is not given, then current date/time will be used.
         * @summary Uploads a file to a Document Space
         * @param {string} id 
         * @param {string} [path] 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload: async (id: string, path?: string, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling upload.');
            }
            const localVarPath = `/v2/document-space/spaces/{id}/files/upload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentSpaceControllerApi - functional programming interface
 * @export
 */
export const DocumentSpaceControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds an App Client to a Document Space with specified privileges
         * @summary Adds an App Client to a Document Space
         * @param {string} id 
         * @param {DocumentSpaceAppClientMemberRequestDto} documentSpaceAppClientMemberRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAppClientToDocumentSpace(id: string, documentSpaceAppClientMemberRequestDto: DocumentSpaceAppClientMemberRequestDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).addAppClientToDocumentSpace(id, documentSpaceAppClientMemberRequestDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Adds a new entry to a favorites collection. If no collection exists, it also creates one.
         * @param {string} id 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEntityToFavorites(id: string, entryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilePathSpec>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).addEntityToFavorites(id, entryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Adds a new entry provided with a path to a favorites collection. If no collection exists, it also creates one.
         * @param {string} id 
         * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPathEntityToFavorites(id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).addPathEntityToFavorites(id, documentSpacePathItemsDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adds a user to a Document Space with specified privileges
         * @summary Adds a user to a Document Space
         * @param {string} id 
         * @param {DocumentSpaceDashboardMemberRequestDto} documentSpaceDashboardMemberRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserToDocumentSpace(id: string, documentSpaceDashboardMemberRequestDto: DocumentSpaceDashboardMemberRequestDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).addUserToDocumentSpace(id, documentSpaceDashboardMemberRequestDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Archives (soft-delete) selected files/folder from a Document Space
         * @summary Archives selected item(s) from a Document Space
         * @param {string} id 
         * @param {DocumentSpaceArchiveItemsDto} documentSpaceArchiveItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveItems(id: string, documentSpaceArchiveItemsDto: DocumentSpaceArchiveItemsDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).archiveItems(id, documentSpaceArchiveItemsDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adds multiple users via a csv to a Document Space with specified privileges. Returns a list of any errors encountered.
         * @summary Adds multiple users to a Document Space
         * @param {string} id 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchAddUserToDocumentSpace(id: string, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).batchAddUserToDocumentSpace(id, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Copies files either within the same space (if sourceSpaceId is equal to the destination space \'id\').  If copying cross-space, then the user must have READ privileges at a minimum on the source space ID - and obviously needs at least WRITE at the destination
         * @summary Copies file(s)/folders(s) from one location in a document space to another within same space.
         * @param {string} id Destination Space UUID
         * @param {{ [key: string]: string; }} requestBody 
         * @param {string} [sourceSpaceId] UUID of the source space (if cross space copying) - otherwise uses current space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyFiles(id: string, requestBody: { [key: string]: string; }, sourceSpaceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).copyFiles(id, requestBody, sourceSpaceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a new folder within a Document Space
         * @param {string} id 
         * @param {DocumentSpaceCreateFolderDto} documentSpaceCreateFolderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolder(id: string, documentSpaceCreateFolderDto: DocumentSpaceCreateFolderDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilePathSpec>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).createFolder(id, documentSpaceCreateFolderDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a Document Space
         * @summary Creates a Document Space
         * @param {DocumentSpaceRequestDto} documentSpaceRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSpace(documentSpaceRequestDto: DocumentSpaceRequestDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentSpaceResponseDto>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).createSpace(documentSpaceRequestDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Archive a single file/folder from a Document Space by parent folder id and item name
         * @summary Archive a file/folder from a Document Space
         * @param {string} id 
         * @param {string} parentFolderId 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArchiveItemBySpaceAndParent(id: string, parentFolderId: string, filename: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).deleteArchiveItemBySpaceAndParent(id, parentFolderId, filename, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a single file from a Document Space by parent folder id and filename
         * @summary Delete from a Document Space
         * @param {string} id 
         * @param {string} parentFolderId 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileBySpaceAndParent(id: string, parentFolderId: string, filename: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).deleteFileBySpaceAndParent(id, parentFolderId, filename, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes selected files/folder from a Document Space
         * @summary Deletes selected item(s) from a Document Space
         * @param {string} id 
         * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItems(id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).deleteItems(id, documentSpacePathItemsDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a Document Space
         * @summary Deletes a Document Space
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSpace(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).deleteSpace(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Downloads all files from a space as a zip file
         * @summary Download all files from a Document Space
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadAllFilesInSpace(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).downloadAllFilesInSpace(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Download a single file from a Document Space
         * @summary Download from a Document Space
         * @param {string} id 
         * @param {boolean} [download] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(id: string, download?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).downloadFile(id, download, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Download a single file (folders not allowed) from a Document Space by parent folder id and filename
         * @summary Download a file from a Document Space
         * @param {string} id 
         * @param {string} parentFolderId 
         * @param {string} filename 
         * @param {boolean} [download] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFileBySpaceAndParent(id: string, parentFolderId: string, filename: string, download?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).downloadFileBySpaceAndParent(id, parentFolderId, filename, download, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Downloads multiple files from the same folder into a zip file
         * @summary Download chosen files from a chosen Document Space folder
         * @param {string} id 
         * @param {Set<string>} files 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFiles(id: string, files: Set<string>, path?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).downloadFiles(id, files, path, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists folders and files that are archived -folders/sub-folders cannot be navigated into while in archived status - just folder name is shown
         * @summary List folders and files that are in Archived status
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dumpArchivedContents(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<S3PaginationDto>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).dumpArchivedContents(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists folders and files contained within given folder path - one level deep (does not recurse into any sub-folders)
         * @summary List folders and files at given path
         * @param {string} id 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dumpContentsAtPath(id: string, path?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<S3PaginationDto>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).dumpContentsAtPath(id, path, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieves all archived files for the requesting user for spaces they have access to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllArchivedFilesForAuthUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<S3PaginationDto>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).getAllArchivedFilesForAuthUser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets the App Clients that can access a space and their privileges
         * @summary Gets the App Clients that can access a given Document Space
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAppClientUsersForDocumentSpace(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentSpaceAppClientResponseDtoWrapper>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).getAppClientUsersForDocumentSpace(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The list includes those that are not associated currently with given space
         * @summary Gets list of App Clients that are available to assignment to given doc space
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAppClientsForAssignmentToDocumentSpace(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppClientSummaryDtoResponseWrapper>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).getAppClientsForAssignmentToDocumentSpace(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets members for a Document Space. Pagination enabled.
         * @summary Gets the members for a Document Space
         * @param {string} id 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardUsersForDocumentSpace(id: string, page?: number, size?: number, sort?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentSpaceDashboardMemberResponseDtoResponseWrapper>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).getDashboardUsersForDocumentSpace(id, page, size, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets path of entryId and document space id.
         * @param {string} id 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentSpaceEntryPath(id: string, entryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).getDocumentSpaceEntryPath(id, entryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets entries from a favorites collection. If no collection exists, returns empty list.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFavorites(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentSpaceUserCollectionResponseDtoWrapper>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).getFavorites(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a folder\'s total size
         * @param {string} id 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderSize(id: string, path?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentSpaceFolderInfoDto>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).getFolderSize(id, path, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieves files from all spaces that the authenticated user has recently uploaded
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentlyUploadedFilesByAuthenticatedUser(page?: number, size?: number, sort?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecentDocumentDtoResponseWrapper>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).getRecentlyUploadedFilesByAuthenticatedUser(page, size, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requester must have at least READ access to provided Space.
         * @summary Gets provided space\'s recently uploaded files/updated files activity
         * @param {string} id Space UUID
         * @param {string} [date] ISO UTC date/time to search from looking back
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentsForSpace(id: string, date?: string, page?: number, size?: number, sort?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecentDocumentDtoResponseWrapper>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).getRecentsForSpace(id, date, page, size, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the Document Space privileges of the requesting user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSelfDashboardUserPrivilegesForDocumentSpace(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentSpacePrivilegeDtoResponseWrapper>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).getSelfDashboardUserPrivilegesForDocumentSpace(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieves all document spaces for the requesting user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpaces(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentSpaceResponseDtoResponseWrapper>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).getSpaces(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets files from a space. This is not a download
         * @summary Retrieves files from a space
         * @param {string} id 
         * @param {string} [continuation] the continuation token
         * @param {number} [limit] page limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listObjects(id: string, continuation?: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<S3PaginationDto>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).listObjects(id, continuation, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Moves files either within the same space (if sourceSpaceId is equal to the destination space \'id\').  If moving cross-space, then the user must have READ privileges at a minimum on the source space ID - and obviously needs at least WRITE at the destination
         * @summary Moves file(s)/folders(s) from one location in a document space to another within same space.
         * @param {string} id UUID of the destination space
         * @param {{ [key: string]: string; }} requestBody 
         * @param {string} [sourceSpaceId] UUID of the source space (if cross space moving) - otherwise uses current space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveFiles(id: string, requestBody: { [key: string]: string; }, sourceSpaceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).moveFiles(id, requestBody, sourceSpaceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sets the default Document Space privileges of the requesting user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchSelfDocumentSpaceDefault(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).patchSelfDocumentSpaceDefault(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes App Client(s) from a Document Space and their privileges
         * @summary Removes one or more App Client(s) from a Document Space
         * @param {string} id 
         * @param {string} appClientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAppClientFromDocumentSpace(id: string, appClientId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).removeAppClientFromDocumentSpace(id, appClientId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Removes an entry from a favorites collection.
         * @param {string} id 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeEntityFromFavorites(id: string, entryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilePathSpec>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).removeEntityFromFavorites(id, entryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Removes an entry provided with a path from a favorites collection.
         * @param {string} id 
         * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePathEntityFromFavorites(id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).removePathEntityFromFavorites(id, documentSpacePathItemsDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes Dashboard Users from a Document Space and their privileges
         * @summary Removes one or more Dashboard User members from a Document Space
         * @param {string} id 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFromDocumentSpace(id: string, requestBody: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).removeUserFromDocumentSpace(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Renames a file
         * @param {string} id 
         * @param {DocumentSpaceRenameFileDto} documentSpaceRenameFileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameFile(id: string, documentSpaceRenameFileDto: DocumentSpaceRenameFileDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).renameFile(id, documentSpaceRenameFileDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Renames a folder at a given path
         * @param {string} id 
         * @param {DocumentSpaceRenameFolderDto} documentSpaceRenameFolderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameFolder(id: string, documentSpaceRenameFolderDto: DocumentSpaceRenameFolderDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentSpaceRenameFolderDto>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).renameFolder(id, documentSpaceRenameFolderDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requester must have at least READ access to provided Space.  Query is case-insensitive and is treated like a filename that \'contains\'...
         * @summary Search a document space for a filename or part of a filename
         * @param {string} id Space UUID
         * @param {DocumentSpaceSearchDto} documentSpaceSearchDto 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDocumentSpace(id: string, documentSpaceSearchDto: DocumentSpaceSearchDto, page?: number, size?: number, sort?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentMobileDtoResponseWrapper>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).searchDocumentSpace(id, documentSpaceSearchDto, page, size, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Similar to usage of the Unix stat command
         * @summary Get info about a file(s) at given path
         * @param {string} id 
         * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statElementsAtPath(id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilePathSpecWrapper>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).statElementsAtPath(id, documentSpacePathItemsDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Un-archives selected files/folder from a Document Space
         * @summary Un-archives selected item(s) from a Document Space
         * @param {string} id 
         * @param {DocumentSpaceUnArchiveItemsDto} documentSpaceUnArchiveItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unArchiveItems(id: string, documentSpaceUnArchiveItemsDto: DocumentSpaceUnArchiveItemsDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).unArchiveItems(id, documentSpaceUnArchiveItemsDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Uploads a file to a Document Space. API will attempt to use the `Last-Modified` date (formatted as long epoch date) in the header in order to keep the uploaded copy\'s modified date to track its origin.  If that header is not given, then current date/time will be used.
         * @summary Uploads a file to a Document Space
         * @param {string} id 
         * @param {string} [path] 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upload(id: string, path?: string, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await DocumentSpaceControllerApiAxiosParamCreator(configuration).upload(id, path, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DocumentSpaceControllerApi - factory interface
 * @export
 */
export const DocumentSpaceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adds an App Client to a Document Space with specified privileges
         * @summary Adds an App Client to a Document Space
         * @param {string} id 
         * @param {DocumentSpaceAppClientMemberRequestDto} documentSpaceAppClientMemberRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAppClientToDocumentSpace(id: string, documentSpaceAppClientMemberRequestDto: DocumentSpaceAppClientMemberRequestDto, options?: any): AxiosPromise<object> {
            return DocumentSpaceControllerApiFp(configuration).addAppClientToDocumentSpace(id, documentSpaceAppClientMemberRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a new entry to a favorites collection. If no collection exists, it also creates one.
         * @param {string} id 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntityToFavorites(id: string, entryId: string, options?: any): AxiosPromise<FilePathSpec> {
            return DocumentSpaceControllerApiFp(configuration).addEntityToFavorites(id, entryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a new entry provided with a path to a favorites collection. If no collection exists, it also creates one.
         * @param {string} id 
         * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPathEntityToFavorites(id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options?: any): AxiosPromise<void> {
            return DocumentSpaceControllerApiFp(configuration).addPathEntityToFavorites(id, documentSpacePathItemsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a user to a Document Space with specified privileges
         * @summary Adds a user to a Document Space
         * @param {string} id 
         * @param {DocumentSpaceDashboardMemberRequestDto} documentSpaceDashboardMemberRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToDocumentSpace(id: string, documentSpaceDashboardMemberRequestDto: DocumentSpaceDashboardMemberRequestDto, options?: any): AxiosPromise<object> {
            return DocumentSpaceControllerApiFp(configuration).addUserToDocumentSpace(id, documentSpaceDashboardMemberRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Archives (soft-delete) selected files/folder from a Document Space
         * @summary Archives selected item(s) from a Document Space
         * @param {string} id 
         * @param {DocumentSpaceArchiveItemsDto} documentSpaceArchiveItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveItems(id: string, documentSpaceArchiveItemsDto: DocumentSpaceArchiveItemsDto, options?: any): AxiosPromise<object> {
            return DocumentSpaceControllerApiFp(configuration).archiveItems(id, documentSpaceArchiveItemsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds multiple users via a csv to a Document Space with specified privileges. Returns a list of any errors encountered.
         * @summary Adds multiple users to a Document Space
         * @param {string} id 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchAddUserToDocumentSpace(id: string, file?: any, options?: any): AxiosPromise<Array<string>> {
            return DocumentSpaceControllerApiFp(configuration).batchAddUserToDocumentSpace(id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Copies files either within the same space (if sourceSpaceId is equal to the destination space \'id\').  If copying cross-space, then the user must have READ privileges at a minimum on the source space ID - and obviously needs at least WRITE at the destination
         * @summary Copies file(s)/folders(s) from one location in a document space to another within same space.
         * @param {string} id Destination Space UUID
         * @param {{ [key: string]: string; }} requestBody 
         * @param {string} [sourceSpaceId] UUID of the source space (if cross space copying) - otherwise uses current space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyFiles(id: string, requestBody: { [key: string]: string; }, sourceSpaceId?: string, options?: any): AxiosPromise<object> {
            return DocumentSpaceControllerApiFp(configuration).copyFiles(id, requestBody, sourceSpaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new folder within a Document Space
         * @param {string} id 
         * @param {DocumentSpaceCreateFolderDto} documentSpaceCreateFolderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder(id: string, documentSpaceCreateFolderDto: DocumentSpaceCreateFolderDto, options?: any): AxiosPromise<FilePathSpec> {
            return DocumentSpaceControllerApiFp(configuration).createFolder(id, documentSpaceCreateFolderDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Document Space
         * @summary Creates a Document Space
         * @param {DocumentSpaceRequestDto} documentSpaceRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpace(documentSpaceRequestDto: DocumentSpaceRequestDto, options?: any): AxiosPromise<DocumentSpaceResponseDto> {
            return DocumentSpaceControllerApiFp(configuration).createSpace(documentSpaceRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Archive a single file/folder from a Document Space by parent folder id and item name
         * @summary Archive a file/folder from a Document Space
         * @param {string} id 
         * @param {string} parentFolderId 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArchiveItemBySpaceAndParent(id: string, parentFolderId: string, filename: string, options?: any): AxiosPromise<void> {
            return DocumentSpaceControllerApiFp(configuration).deleteArchiveItemBySpaceAndParent(id, parentFolderId, filename, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a single file from a Document Space by parent folder id and filename
         * @summary Delete from a Document Space
         * @param {string} id 
         * @param {string} parentFolderId 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileBySpaceAndParent(id: string, parentFolderId: string, filename: string, options?: any): AxiosPromise<void> {
            return DocumentSpaceControllerApiFp(configuration).deleteFileBySpaceAndParent(id, parentFolderId, filename, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes selected files/folder from a Document Space
         * @summary Deletes selected item(s) from a Document Space
         * @param {string} id 
         * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItems(id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options?: any): AxiosPromise<object> {
            return DocumentSpaceControllerApiFp(configuration).deleteItems(id, documentSpacePathItemsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a Document Space
         * @summary Deletes a Document Space
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpace(id: string, options?: any): AxiosPromise<object> {
            return DocumentSpaceControllerApiFp(configuration).deleteSpace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads all files from a space as a zip file
         * @summary Download all files from a Document Space
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAllFilesInSpace(id: string, options?: any): AxiosPromise<object> {
            return DocumentSpaceControllerApiFp(configuration).downloadAllFilesInSpace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Download a single file from a Document Space
         * @summary Download from a Document Space
         * @param {string} id 
         * @param {boolean} [download] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(id: string, download?: boolean, options?: any): AxiosPromise<any> {
            return DocumentSpaceControllerApiFp(configuration).downloadFile(id, download, options).then((request) => request(axios, basePath));
        },
        /**
         * Download a single file (folders not allowed) from a Document Space by parent folder id and filename
         * @summary Download a file from a Document Space
         * @param {string} id 
         * @param {string} parentFolderId 
         * @param {string} filename 
         * @param {boolean} [download] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFileBySpaceAndParent(id: string, parentFolderId: string, filename: string, download?: boolean, options?: any): AxiosPromise<any> {
            return DocumentSpaceControllerApiFp(configuration).downloadFileBySpaceAndParent(id, parentFolderId, filename, download, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads multiple files from the same folder into a zip file
         * @summary Download chosen files from a chosen Document Space folder
         * @param {string} id 
         * @param {Set<string>} files 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFiles(id: string, files: Set<string>, path?: string, options?: any): AxiosPromise<object> {
            return DocumentSpaceControllerApiFp(configuration).downloadFiles(id, files, path, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists folders and files that are archived -folders/sub-folders cannot be navigated into while in archived status - just folder name is shown
         * @summary List folders and files that are in Archived status
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dumpArchivedContents(id: string, options?: any): AxiosPromise<S3PaginationDto> {
            return DocumentSpaceControllerApiFp(configuration).dumpArchivedContents(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists folders and files contained within given folder path - one level deep (does not recurse into any sub-folders)
         * @summary List folders and files at given path
         * @param {string} id 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dumpContentsAtPath(id: string, path?: string, options?: any): AxiosPromise<S3PaginationDto> {
            return DocumentSpaceControllerApiFp(configuration).dumpContentsAtPath(id, path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves all archived files for the requesting user for spaces they have access to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArchivedFilesForAuthUser(options?: any): AxiosPromise<S3PaginationDto> {
            return DocumentSpaceControllerApiFp(configuration).getAllArchivedFilesForAuthUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the App Clients that can access a space and their privileges
         * @summary Gets the App Clients that can access a given Document Space
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppClientUsersForDocumentSpace(id: string, options?: any): AxiosPromise<DocumentSpaceAppClientResponseDtoWrapper> {
            return DocumentSpaceControllerApiFp(configuration).getAppClientUsersForDocumentSpace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * The list includes those that are not associated currently with given space
         * @summary Gets list of App Clients that are available to assignment to given doc space
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppClientsForAssignmentToDocumentSpace(id: string, options?: any): AxiosPromise<AppClientSummaryDtoResponseWrapper> {
            return DocumentSpaceControllerApiFp(configuration).getAppClientsForAssignmentToDocumentSpace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets members for a Document Space. Pagination enabled.
         * @summary Gets the members for a Document Space
         * @param {string} id 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardUsersForDocumentSpace(id: string, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<DocumentSpaceDashboardMemberResponseDtoResponseWrapper> {
            return DocumentSpaceControllerApiFp(configuration).getDashboardUsersForDocumentSpace(id, page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets path of entryId and document space id.
         * @param {string} id 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentSpaceEntryPath(id: string, entryId: string, options?: any): AxiosPromise<string> {
            return DocumentSpaceControllerApiFp(configuration).getDocumentSpaceEntryPath(id, entryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets entries from a favorites collection. If no collection exists, returns empty list.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavorites(id: string, options?: any): AxiosPromise<DocumentSpaceUserCollectionResponseDtoWrapper> {
            return DocumentSpaceControllerApiFp(configuration).getFavorites(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a folder\'s total size
         * @param {string} id 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderSize(id: string, path?: string, options?: any): AxiosPromise<DocumentSpaceFolderInfoDto> {
            return DocumentSpaceControllerApiFp(configuration).getFolderSize(id, path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves files from all spaces that the authenticated user has recently uploaded
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentlyUploadedFilesByAuthenticatedUser(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<RecentDocumentDtoResponseWrapper> {
            return DocumentSpaceControllerApiFp(configuration).getRecentlyUploadedFilesByAuthenticatedUser(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Requester must have at least READ access to provided Space.
         * @summary Gets provided space\'s recently uploaded files/updated files activity
         * @param {string} id Space UUID
         * @param {string} [date] ISO UTC date/time to search from looking back
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentsForSpace(id: string, date?: string, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<RecentDocumentDtoResponseWrapper> {
            return DocumentSpaceControllerApiFp(configuration).getRecentsForSpace(id, date, page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the Document Space privileges of the requesting user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSelfDashboardUserPrivilegesForDocumentSpace(id: string, options?: any): AxiosPromise<DocumentSpacePrivilegeDtoResponseWrapper> {
            return DocumentSpaceControllerApiFp(configuration).getSelfDashboardUserPrivilegesForDocumentSpace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves all document spaces for the requesting user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpaces(options?: any): AxiosPromise<DocumentSpaceResponseDtoResponseWrapper> {
            return DocumentSpaceControllerApiFp(configuration).getSpaces(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets files from a space. This is not a download
         * @summary Retrieves files from a space
         * @param {string} id 
         * @param {string} [continuation] the continuation token
         * @param {number} [limit] page limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listObjects(id: string, continuation?: string, limit?: number, options?: any): AxiosPromise<S3PaginationDto> {
            return DocumentSpaceControllerApiFp(configuration).listObjects(id, continuation, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Moves files either within the same space (if sourceSpaceId is equal to the destination space \'id\').  If moving cross-space, then the user must have READ privileges at a minimum on the source space ID - and obviously needs at least WRITE at the destination
         * @summary Moves file(s)/folders(s) from one location in a document space to another within same space.
         * @param {string} id UUID of the destination space
         * @param {{ [key: string]: string; }} requestBody 
         * @param {string} [sourceSpaceId] UUID of the source space (if cross space moving) - otherwise uses current space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFiles(id: string, requestBody: { [key: string]: string; }, sourceSpaceId?: string, options?: any): AxiosPromise<object> {
            return DocumentSpaceControllerApiFp(configuration).moveFiles(id, requestBody, sourceSpaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets the default Document Space privileges of the requesting user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSelfDocumentSpaceDefault(id: string, options?: any): AxiosPromise<void> {
            return DocumentSpaceControllerApiFp(configuration).patchSelfDocumentSpaceDefault(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes App Client(s) from a Document Space and their privileges
         * @summary Removes one or more App Client(s) from a Document Space
         * @param {string} id 
         * @param {string} appClientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAppClientFromDocumentSpace(id: string, appClientId: string, options?: any): AxiosPromise<object> {
            return DocumentSpaceControllerApiFp(configuration).removeAppClientFromDocumentSpace(id, appClientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes an entry from a favorites collection.
         * @param {string} id 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEntityFromFavorites(id: string, entryId: string, options?: any): AxiosPromise<FilePathSpec> {
            return DocumentSpaceControllerApiFp(configuration).removeEntityFromFavorites(id, entryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes an entry provided with a path from a favorites collection.
         * @param {string} id 
         * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePathEntityFromFavorites(id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options?: any): AxiosPromise<void> {
            return DocumentSpaceControllerApiFp(configuration).removePathEntityFromFavorites(id, documentSpacePathItemsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes Dashboard Users from a Document Space and their privileges
         * @summary Removes one or more Dashboard User members from a Document Space
         * @param {string} id 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromDocumentSpace(id: string, requestBody: Array<string>, options?: any): AxiosPromise<object> {
            return DocumentSpaceControllerApiFp(configuration).removeUserFromDocumentSpace(id, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Renames a file
         * @param {string} id 
         * @param {DocumentSpaceRenameFileDto} documentSpaceRenameFileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameFile(id: string, documentSpaceRenameFileDto: DocumentSpaceRenameFileDto, options?: any): AxiosPromise<object> {
            return DocumentSpaceControllerApiFp(configuration).renameFile(id, documentSpaceRenameFileDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Renames a folder at a given path
         * @param {string} id 
         * @param {DocumentSpaceRenameFolderDto} documentSpaceRenameFolderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameFolder(id: string, documentSpaceRenameFolderDto: DocumentSpaceRenameFolderDto, options?: any): AxiosPromise<DocumentSpaceRenameFolderDto> {
            return DocumentSpaceControllerApiFp(configuration).renameFolder(id, documentSpaceRenameFolderDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Requester must have at least READ access to provided Space.  Query is case-insensitive and is treated like a filename that \'contains\'...
         * @summary Search a document space for a filename or part of a filename
         * @param {string} id Space UUID
         * @param {DocumentSpaceSearchDto} documentSpaceSearchDto 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocumentSpace(id: string, documentSpaceSearchDto: DocumentSpaceSearchDto, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<DocumentMobileDtoResponseWrapper> {
            return DocumentSpaceControllerApiFp(configuration).searchDocumentSpace(id, documentSpaceSearchDto, page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Similar to usage of the Unix stat command
         * @summary Get info about a file(s) at given path
         * @param {string} id 
         * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statElementsAtPath(id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options?: any): AxiosPromise<FilePathSpecWrapper> {
            return DocumentSpaceControllerApiFp(configuration).statElementsAtPath(id, documentSpacePathItemsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Un-archives selected files/folder from a Document Space
         * @summary Un-archives selected item(s) from a Document Space
         * @param {string} id 
         * @param {DocumentSpaceUnArchiveItemsDto} documentSpaceUnArchiveItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unArchiveItems(id: string, documentSpaceUnArchiveItemsDto: DocumentSpaceUnArchiveItemsDto, options?: any): AxiosPromise<object> {
            return DocumentSpaceControllerApiFp(configuration).unArchiveItems(id, documentSpaceUnArchiveItemsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a file to a Document Space. API will attempt to use the `Last-Modified` date (formatted as long epoch date) in the header in order to keep the uploaded copy\'s modified date to track its origin.  If that header is not given, then current date/time will be used.
         * @summary Uploads a file to a Document Space
         * @param {string} id 
         * @param {string} [path] 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload(id: string, path?: string, file?: any, options?: any): AxiosPromise<{ [key: string]: string; }> {
            return DocumentSpaceControllerApiFp(configuration).upload(id, path, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentSpaceControllerApi - interface
 * @export
 * @interface DocumentSpaceControllerApi
 */
export interface DocumentSpaceControllerApiInterface {
    /**
     * Adds an App Client to a Document Space with specified privileges
     * @summary Adds an App Client to a Document Space
     * @param {string} id 
     * @param {DocumentSpaceAppClientMemberRequestDto} documentSpaceAppClientMemberRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    addAppClientToDocumentSpace(id: string, documentSpaceAppClientMemberRequestDto: DocumentSpaceAppClientMemberRequestDto, options?: any): AxiosPromise<object>;

    /**
     * 
     * @summary Adds a new entry to a favorites collection. If no collection exists, it also creates one.
     * @param {string} id 
     * @param {string} entryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    addEntityToFavorites(id: string, entryId: string, options?: any): AxiosPromise<FilePathSpec>;

    /**
     * 
     * @summary Adds a new entry provided with a path to a favorites collection. If no collection exists, it also creates one.
     * @param {string} id 
     * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    addPathEntityToFavorites(id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options?: any): AxiosPromise<void>;

    /**
     * Adds a user to a Document Space with specified privileges
     * @summary Adds a user to a Document Space
     * @param {string} id 
     * @param {DocumentSpaceDashboardMemberRequestDto} documentSpaceDashboardMemberRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    addUserToDocumentSpace(id: string, documentSpaceDashboardMemberRequestDto: DocumentSpaceDashboardMemberRequestDto, options?: any): AxiosPromise<object>;

    /**
     * Archives (soft-delete) selected files/folder from a Document Space
     * @summary Archives selected item(s) from a Document Space
     * @param {string} id 
     * @param {DocumentSpaceArchiveItemsDto} documentSpaceArchiveItemsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    archiveItems(id: string, documentSpaceArchiveItemsDto: DocumentSpaceArchiveItemsDto, options?: any): AxiosPromise<object>;

    /**
     * Adds multiple users via a csv to a Document Space with specified privileges. Returns a list of any errors encountered.
     * @summary Adds multiple users to a Document Space
     * @param {string} id 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    batchAddUserToDocumentSpace(id: string, file?: any, options?: any): AxiosPromise<Array<string>>;

    /**
     * Copies files either within the same space (if sourceSpaceId is equal to the destination space \'id\').  If copying cross-space, then the user must have READ privileges at a minimum on the source space ID - and obviously needs at least WRITE at the destination
     * @summary Copies file(s)/folders(s) from one location in a document space to another within same space.
     * @param {string} id Destination Space UUID
     * @param {{ [key: string]: string; }} requestBody 
     * @param {string} [sourceSpaceId] UUID of the source space (if cross space copying) - otherwise uses current space
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    copyFiles(id: string, requestBody: { [key: string]: string; }, sourceSpaceId?: string, options?: any): AxiosPromise<object>;

    /**
     * 
     * @summary Creates a new folder within a Document Space
     * @param {string} id 
     * @param {DocumentSpaceCreateFolderDto} documentSpaceCreateFolderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    createFolder(id: string, documentSpaceCreateFolderDto: DocumentSpaceCreateFolderDto, options?: any): AxiosPromise<FilePathSpec>;

    /**
     * Creates a Document Space
     * @summary Creates a Document Space
     * @param {DocumentSpaceRequestDto} documentSpaceRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    createSpace(documentSpaceRequestDto: DocumentSpaceRequestDto, options?: any): AxiosPromise<DocumentSpaceResponseDto>;

    /**
     * Archive a single file/folder from a Document Space by parent folder id and item name
     * @summary Archive a file/folder from a Document Space
     * @param {string} id 
     * @param {string} parentFolderId 
     * @param {string} filename 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    deleteArchiveItemBySpaceAndParent(id: string, parentFolderId: string, filename: string, options?: any): AxiosPromise<void>;

    /**
     * Delete a single file from a Document Space by parent folder id and filename
     * @summary Delete from a Document Space
     * @param {string} id 
     * @param {string} parentFolderId 
     * @param {string} filename 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    deleteFileBySpaceAndParent(id: string, parentFolderId: string, filename: string, options?: any): AxiosPromise<void>;

    /**
     * Deletes selected files/folder from a Document Space
     * @summary Deletes selected item(s) from a Document Space
     * @param {string} id 
     * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    deleteItems(id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options?: any): AxiosPromise<object>;

    /**
     * Deletes a Document Space
     * @summary Deletes a Document Space
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    deleteSpace(id: string, options?: any): AxiosPromise<object>;

    /**
     * Downloads all files from a space as a zip file
     * @summary Download all files from a Document Space
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    downloadAllFilesInSpace(id: string, options?: any): AxiosPromise<object>;

    /**
     * Download a single file from a Document Space
     * @summary Download from a Document Space
     * @param {string} id 
     * @param {boolean} [download] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    downloadFile(id: string, download?: boolean, options?: any): AxiosPromise<any>;

    /**
     * Download a single file (folders not allowed) from a Document Space by parent folder id and filename
     * @summary Download a file from a Document Space
     * @param {string} id 
     * @param {string} parentFolderId 
     * @param {string} filename 
     * @param {boolean} [download] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    downloadFileBySpaceAndParent(id: string, parentFolderId: string, filename: string, download?: boolean, options?: any): AxiosPromise<any>;

    /**
     * Downloads multiple files from the same folder into a zip file
     * @summary Download chosen files from a chosen Document Space folder
     * @param {string} id 
     * @param {Set<string>} files 
     * @param {string} [path] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    downloadFiles(id: string, files: Set<string>, path?: string, options?: any): AxiosPromise<object>;

    /**
     * Lists folders and files that are archived -folders/sub-folders cannot be navigated into while in archived status - just folder name is shown
     * @summary List folders and files that are in Archived status
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    dumpArchivedContents(id: string, options?: any): AxiosPromise<S3PaginationDto>;

    /**
     * Lists folders and files contained within given folder path - one level deep (does not recurse into any sub-folders)
     * @summary List folders and files at given path
     * @param {string} id 
     * @param {string} [path] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    dumpContentsAtPath(id: string, path?: string, options?: any): AxiosPromise<S3PaginationDto>;

    /**
     * 
     * @summary Retrieves all archived files for the requesting user for spaces they have access to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    getAllArchivedFilesForAuthUser(options?: any): AxiosPromise<S3PaginationDto>;

    /**
     * Gets the App Clients that can access a space and their privileges
     * @summary Gets the App Clients that can access a given Document Space
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    getAppClientUsersForDocumentSpace(id: string, options?: any): AxiosPromise<DocumentSpaceAppClientResponseDtoWrapper>;

    /**
     * The list includes those that are not associated currently with given space
     * @summary Gets list of App Clients that are available to assignment to given doc space
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    getAppClientsForAssignmentToDocumentSpace(id: string, options?: any): AxiosPromise<AppClientSummaryDtoResponseWrapper>;

    /**
     * Gets members for a Document Space. Pagination enabled.
     * @summary Gets the members for a Document Space
     * @param {string} id 
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    getDashboardUsersForDocumentSpace(id: string, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<DocumentSpaceDashboardMemberResponseDtoResponseWrapper>;

    /**
     * 
     * @summary Gets path of entryId and document space id.
     * @param {string} id 
     * @param {string} entryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    getDocumentSpaceEntryPath(id: string, entryId: string, options?: any): AxiosPromise<string>;

    /**
     * 
     * @summary Gets entries from a favorites collection. If no collection exists, returns empty list.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    getFavorites(id: string, options?: any): AxiosPromise<DocumentSpaceUserCollectionResponseDtoWrapper>;

    /**
     * 
     * @summary Get a folder\'s total size
     * @param {string} id 
     * @param {string} [path] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    getFolderSize(id: string, path?: string, options?: any): AxiosPromise<DocumentSpaceFolderInfoDto>;

    /**
     * 
     * @summary Retrieves files from all spaces that the authenticated user has recently uploaded
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    getRecentlyUploadedFilesByAuthenticatedUser(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<RecentDocumentDtoResponseWrapper>;

    /**
     * Requester must have at least READ access to provided Space.
     * @summary Gets provided space\'s recently uploaded files/updated files activity
     * @param {string} id Space UUID
     * @param {string} [date] ISO UTC date/time to search from looking back
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    getRecentsForSpace(id: string, date?: string, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<RecentDocumentDtoResponseWrapper>;

    /**
     * 
     * @summary Gets the Document Space privileges of the requesting user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    getSelfDashboardUserPrivilegesForDocumentSpace(id: string, options?: any): AxiosPromise<DocumentSpacePrivilegeDtoResponseWrapper>;

    /**
     * 
     * @summary Retrieves all document spaces for the requesting user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    getSpaces(options?: any): AxiosPromise<DocumentSpaceResponseDtoResponseWrapper>;

    /**
     * Gets files from a space. This is not a download
     * @summary Retrieves files from a space
     * @param {string} id 
     * @param {string} [continuation] the continuation token
     * @param {number} [limit] page limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    listObjects(id: string, continuation?: string, limit?: number, options?: any): AxiosPromise<S3PaginationDto>;

    /**
     * Moves files either within the same space (if sourceSpaceId is equal to the destination space \'id\').  If moving cross-space, then the user must have READ privileges at a minimum on the source space ID - and obviously needs at least WRITE at the destination
     * @summary Moves file(s)/folders(s) from one location in a document space to another within same space.
     * @param {string} id UUID of the destination space
     * @param {{ [key: string]: string; }} requestBody 
     * @param {string} [sourceSpaceId] UUID of the source space (if cross space moving) - otherwise uses current space
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    moveFiles(id: string, requestBody: { [key: string]: string; }, sourceSpaceId?: string, options?: any): AxiosPromise<object>;

    /**
     * 
     * @summary Sets the default Document Space privileges of the requesting user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    patchSelfDocumentSpaceDefault(id: string, options?: any): AxiosPromise<void>;

    /**
     * Removes App Client(s) from a Document Space and their privileges
     * @summary Removes one or more App Client(s) from a Document Space
     * @param {string} id 
     * @param {string} appClientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    removeAppClientFromDocumentSpace(id: string, appClientId: string, options?: any): AxiosPromise<object>;

    /**
     * 
     * @summary Removes an entry from a favorites collection.
     * @param {string} id 
     * @param {string} entryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    removeEntityFromFavorites(id: string, entryId: string, options?: any): AxiosPromise<FilePathSpec>;

    /**
     * 
     * @summary Removes an entry provided with a path from a favorites collection.
     * @param {string} id 
     * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    removePathEntityFromFavorites(id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options?: any): AxiosPromise<void>;

    /**
     * Removes Dashboard Users from a Document Space and their privileges
     * @summary Removes one or more Dashboard User members from a Document Space
     * @param {string} id 
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    removeUserFromDocumentSpace(id: string, requestBody: Array<string>, options?: any): AxiosPromise<object>;

    /**
     * 
     * @summary Renames a file
     * @param {string} id 
     * @param {DocumentSpaceRenameFileDto} documentSpaceRenameFileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    renameFile(id: string, documentSpaceRenameFileDto: DocumentSpaceRenameFileDto, options?: any): AxiosPromise<object>;

    /**
     * 
     * @summary Renames a folder at a given path
     * @param {string} id 
     * @param {DocumentSpaceRenameFolderDto} documentSpaceRenameFolderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    renameFolder(id: string, documentSpaceRenameFolderDto: DocumentSpaceRenameFolderDto, options?: any): AxiosPromise<DocumentSpaceRenameFolderDto>;

    /**
     * Requester must have at least READ access to provided Space.  Query is case-insensitive and is treated like a filename that \'contains\'...
     * @summary Search a document space for a filename or part of a filename
     * @param {string} id Space UUID
     * @param {DocumentSpaceSearchDto} documentSpaceSearchDto 
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    searchDocumentSpace(id: string, documentSpaceSearchDto: DocumentSpaceSearchDto, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<DocumentMobileDtoResponseWrapper>;

    /**
     * Similar to usage of the Unix stat command
     * @summary Get info about a file(s) at given path
     * @param {string} id 
     * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    statElementsAtPath(id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options?: any): AxiosPromise<FilePathSpecWrapper>;

    /**
     * Un-archives selected files/folder from a Document Space
     * @summary Un-archives selected item(s) from a Document Space
     * @param {string} id 
     * @param {DocumentSpaceUnArchiveItemsDto} documentSpaceUnArchiveItemsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    unArchiveItems(id: string, documentSpaceUnArchiveItemsDto: DocumentSpaceUnArchiveItemsDto, options?: any): AxiosPromise<object>;

    /**
     * Uploads a file to a Document Space. API will attempt to use the `Last-Modified` date (formatted as long epoch date) in the header in order to keep the uploaded copy\'s modified date to track its origin.  If that header is not given, then current date/time will be used.
     * @summary Uploads a file to a Document Space
     * @param {string} id 
     * @param {string} [path] 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApiInterface
     */
    upload(id: string, path?: string, file?: any, options?: any): AxiosPromise<{ [key: string]: string; }>;

}

/**
 * DocumentSpaceControllerApi - object-oriented interface
 * @export
 * @class DocumentSpaceControllerApi
 * @extends {BaseAPI}
 */
export class DocumentSpaceControllerApi extends BaseAPI implements DocumentSpaceControllerApiInterface {
    /**
     * Adds an App Client to a Document Space with specified privileges
     * @summary Adds an App Client to a Document Space
     * @param {string} id 
     * @param {DocumentSpaceAppClientMemberRequestDto} documentSpaceAppClientMemberRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public addAppClientToDocumentSpace(id: string, documentSpaceAppClientMemberRequestDto: DocumentSpaceAppClientMemberRequestDto, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).addAppClientToDocumentSpace(id, documentSpaceAppClientMemberRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a new entry to a favorites collection. If no collection exists, it also creates one.
     * @param {string} id 
     * @param {string} entryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public addEntityToFavorites(id: string, entryId: string, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).addEntityToFavorites(id, entryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a new entry provided with a path to a favorites collection. If no collection exists, it also creates one.
     * @param {string} id 
     * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public addPathEntityToFavorites(id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).addPathEntityToFavorites(id, documentSpacePathItemsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a user to a Document Space with specified privileges
     * @summary Adds a user to a Document Space
     * @param {string} id 
     * @param {DocumentSpaceDashboardMemberRequestDto} documentSpaceDashboardMemberRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public addUserToDocumentSpace(id: string, documentSpaceDashboardMemberRequestDto: DocumentSpaceDashboardMemberRequestDto, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).addUserToDocumentSpace(id, documentSpaceDashboardMemberRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archives (soft-delete) selected files/folder from a Document Space
     * @summary Archives selected item(s) from a Document Space
     * @param {string} id 
     * @param {DocumentSpaceArchiveItemsDto} documentSpaceArchiveItemsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public archiveItems(id: string, documentSpaceArchiveItemsDto: DocumentSpaceArchiveItemsDto, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).archiveItems(id, documentSpaceArchiveItemsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds multiple users via a csv to a Document Space with specified privileges. Returns a list of any errors encountered.
     * @summary Adds multiple users to a Document Space
     * @param {string} id 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public batchAddUserToDocumentSpace(id: string, file?: any, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).batchAddUserToDocumentSpace(id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Copies files either within the same space (if sourceSpaceId is equal to the destination space \'id\').  If copying cross-space, then the user must have READ privileges at a minimum on the source space ID - and obviously needs at least WRITE at the destination
     * @summary Copies file(s)/folders(s) from one location in a document space to another within same space.
     * @param {string} id Destination Space UUID
     * @param {{ [key: string]: string; }} requestBody 
     * @param {string} [sourceSpaceId] UUID of the source space (if cross space copying) - otherwise uses current space
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public copyFiles(id: string, requestBody: { [key: string]: string; }, sourceSpaceId?: string, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).copyFiles(id, requestBody, sourceSpaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new folder within a Document Space
     * @param {string} id 
     * @param {DocumentSpaceCreateFolderDto} documentSpaceCreateFolderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public createFolder(id: string, documentSpaceCreateFolderDto: DocumentSpaceCreateFolderDto, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).createFolder(id, documentSpaceCreateFolderDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Document Space
     * @summary Creates a Document Space
     * @param {DocumentSpaceRequestDto} documentSpaceRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public createSpace(documentSpaceRequestDto: DocumentSpaceRequestDto, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).createSpace(documentSpaceRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archive a single file/folder from a Document Space by parent folder id and item name
     * @summary Archive a file/folder from a Document Space
     * @param {string} id 
     * @param {string} parentFolderId 
     * @param {string} filename 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public deleteArchiveItemBySpaceAndParent(id: string, parentFolderId: string, filename: string, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).deleteArchiveItemBySpaceAndParent(id, parentFolderId, filename, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a single file from a Document Space by parent folder id and filename
     * @summary Delete from a Document Space
     * @param {string} id 
     * @param {string} parentFolderId 
     * @param {string} filename 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public deleteFileBySpaceAndParent(id: string, parentFolderId: string, filename: string, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).deleteFileBySpaceAndParent(id, parentFolderId, filename, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes selected files/folder from a Document Space
     * @summary Deletes selected item(s) from a Document Space
     * @param {string} id 
     * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public deleteItems(id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).deleteItems(id, documentSpacePathItemsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a Document Space
     * @summary Deletes a Document Space
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public deleteSpace(id: string, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).deleteSpace(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Downloads all files from a space as a zip file
     * @summary Download all files from a Document Space
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public downloadAllFilesInSpace(id: string, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).downloadAllFilesInSpace(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download a single file from a Document Space
     * @summary Download from a Document Space
     * @param {string} id 
     * @param {boolean} [download] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public downloadFile(id: string, download?: boolean, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).downloadFile(id, download, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download a single file (folders not allowed) from a Document Space by parent folder id and filename
     * @summary Download a file from a Document Space
     * @param {string} id 
     * @param {string} parentFolderId 
     * @param {string} filename 
     * @param {boolean} [download] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public downloadFileBySpaceAndParent(id: string, parentFolderId: string, filename: string, download?: boolean, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).downloadFileBySpaceAndParent(id, parentFolderId, filename, download, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Downloads multiple files from the same folder into a zip file
     * @summary Download chosen files from a chosen Document Space folder
     * @param {string} id 
     * @param {Set<string>} files 
     * @param {string} [path] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public downloadFiles(id: string, files: Set<string>, path?: string, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).downloadFiles(id, files, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists folders and files that are archived -folders/sub-folders cannot be navigated into while in archived status - just folder name is shown
     * @summary List folders and files that are in Archived status
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public dumpArchivedContents(id: string, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).dumpArchivedContents(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists folders and files contained within given folder path - one level deep (does not recurse into any sub-folders)
     * @summary List folders and files at given path
     * @param {string} id 
     * @param {string} [path] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public dumpContentsAtPath(id: string, path?: string, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).dumpContentsAtPath(id, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves all archived files for the requesting user for spaces they have access to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public getAllArchivedFilesForAuthUser(options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).getAllArchivedFilesForAuthUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the App Clients that can access a space and their privileges
     * @summary Gets the App Clients that can access a given Document Space
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public getAppClientUsersForDocumentSpace(id: string, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).getAppClientUsersForDocumentSpace(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The list includes those that are not associated currently with given space
     * @summary Gets list of App Clients that are available to assignment to given doc space
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public getAppClientsForAssignmentToDocumentSpace(id: string, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).getAppClientsForAssignmentToDocumentSpace(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets members for a Document Space. Pagination enabled.
     * @summary Gets the members for a Document Space
     * @param {string} id 
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public getDashboardUsersForDocumentSpace(id: string, page?: number, size?: number, sort?: Array<string>, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).getDashboardUsersForDocumentSpace(id, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets path of entryId and document space id.
     * @param {string} id 
     * @param {string} entryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public getDocumentSpaceEntryPath(id: string, entryId: string, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).getDocumentSpaceEntryPath(id, entryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets entries from a favorites collection. If no collection exists, returns empty list.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public getFavorites(id: string, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).getFavorites(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a folder\'s total size
     * @param {string} id 
     * @param {string} [path] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public getFolderSize(id: string, path?: string, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).getFolderSize(id, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves files from all spaces that the authenticated user has recently uploaded
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public getRecentlyUploadedFilesByAuthenticatedUser(page?: number, size?: number, sort?: Array<string>, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).getRecentlyUploadedFilesByAuthenticatedUser(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requester must have at least READ access to provided Space.
     * @summary Gets provided space\'s recently uploaded files/updated files activity
     * @param {string} id Space UUID
     * @param {string} [date] ISO UTC date/time to search from looking back
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public getRecentsForSpace(id: string, date?: string, page?: number, size?: number, sort?: Array<string>, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).getRecentsForSpace(id, date, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the Document Space privileges of the requesting user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public getSelfDashboardUserPrivilegesForDocumentSpace(id: string, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).getSelfDashboardUserPrivilegesForDocumentSpace(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves all document spaces for the requesting user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public getSpaces(options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).getSpaces(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets files from a space. This is not a download
     * @summary Retrieves files from a space
     * @param {string} id 
     * @param {string} [continuation] the continuation token
     * @param {number} [limit] page limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public listObjects(id: string, continuation?: string, limit?: number, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).listObjects(id, continuation, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Moves files either within the same space (if sourceSpaceId is equal to the destination space \'id\').  If moving cross-space, then the user must have READ privileges at a minimum on the source space ID - and obviously needs at least WRITE at the destination
     * @summary Moves file(s)/folders(s) from one location in a document space to another within same space.
     * @param {string} id UUID of the destination space
     * @param {{ [key: string]: string; }} requestBody 
     * @param {string} [sourceSpaceId] UUID of the source space (if cross space moving) - otherwise uses current space
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public moveFiles(id: string, requestBody: { [key: string]: string; }, sourceSpaceId?: string, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).moveFiles(id, requestBody, sourceSpaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets the default Document Space privileges of the requesting user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public patchSelfDocumentSpaceDefault(id: string, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).patchSelfDocumentSpaceDefault(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes App Client(s) from a Document Space and their privileges
     * @summary Removes one or more App Client(s) from a Document Space
     * @param {string} id 
     * @param {string} appClientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public removeAppClientFromDocumentSpace(id: string, appClientId: string, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).removeAppClientFromDocumentSpace(id, appClientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes an entry from a favorites collection.
     * @param {string} id 
     * @param {string} entryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public removeEntityFromFavorites(id: string, entryId: string, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).removeEntityFromFavorites(id, entryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes an entry provided with a path from a favorites collection.
     * @param {string} id 
     * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public removePathEntityFromFavorites(id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).removePathEntityFromFavorites(id, documentSpacePathItemsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes Dashboard Users from a Document Space and their privileges
     * @summary Removes one or more Dashboard User members from a Document Space
     * @param {string} id 
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public removeUserFromDocumentSpace(id: string, requestBody: Array<string>, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).removeUserFromDocumentSpace(id, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Renames a file
     * @param {string} id 
     * @param {DocumentSpaceRenameFileDto} documentSpaceRenameFileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public renameFile(id: string, documentSpaceRenameFileDto: DocumentSpaceRenameFileDto, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).renameFile(id, documentSpaceRenameFileDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Renames a folder at a given path
     * @param {string} id 
     * @param {DocumentSpaceRenameFolderDto} documentSpaceRenameFolderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public renameFolder(id: string, documentSpaceRenameFolderDto: DocumentSpaceRenameFolderDto, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).renameFolder(id, documentSpaceRenameFolderDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requester must have at least READ access to provided Space.  Query is case-insensitive and is treated like a filename that \'contains\'...
     * @summary Search a document space for a filename or part of a filename
     * @param {string} id Space UUID
     * @param {DocumentSpaceSearchDto} documentSpaceSearchDto 
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public searchDocumentSpace(id: string, documentSpaceSearchDto: DocumentSpaceSearchDto, page?: number, size?: number, sort?: Array<string>, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).searchDocumentSpace(id, documentSpaceSearchDto, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Similar to usage of the Unix stat command
     * @summary Get info about a file(s) at given path
     * @param {string} id 
     * @param {DocumentSpacePathItemsDto} documentSpacePathItemsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public statElementsAtPath(id: string, documentSpacePathItemsDto: DocumentSpacePathItemsDto, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).statElementsAtPath(id, documentSpacePathItemsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Un-archives selected files/folder from a Document Space
     * @summary Un-archives selected item(s) from a Document Space
     * @param {string} id 
     * @param {DocumentSpaceUnArchiveItemsDto} documentSpaceUnArchiveItemsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public unArchiveItems(id: string, documentSpaceUnArchiveItemsDto: DocumentSpaceUnArchiveItemsDto, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).unArchiveItems(id, documentSpaceUnArchiveItemsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads a file to a Document Space. API will attempt to use the `Last-Modified` date (formatted as long epoch date) in the header in order to keep the uploaded copy\'s modified date to track its origin.  If that header is not given, then current date/time will be used.
     * @summary Uploads a file to a Document Space
     * @param {string} id 
     * @param {string} [path] 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentSpaceControllerApi
     */
    public upload(id: string, path?: string, file?: any, options?: any) {
        return DocumentSpaceControllerApiFp(this.configuration).upload(id, path, file, options).then((request) => request(this.axios, this.basePath));
    }
}
