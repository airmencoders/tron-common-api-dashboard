/* tslint:disable */
/* eslint-disable */
/**
 * TRON Common API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { BadRequestException } from '../models';
// @ts-ignore
import { EventInfoDto } from '../models';
// @ts-ignore
import { EventInfoDtoResponseWrapper } from '../models';
// @ts-ignore
import { ExceptionResponse } from '../models';
// @ts-ignore
import { PubSubLedgerEntryDtoResponseWrapper } from '../models';
// @ts-ignore
import { SubscriberDto } from '../models';
// @ts-ignore
import { SubscriberDtoResponseWrapper } from '../models';
/**
 * SubscriberControllerApi - axios parameter creator
 * @export
 */
export const SubscriberControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a subscription by its UUID
         * @summary Deletes a subscription
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscription: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cancelSubscription.');
            }
            const localVarPath = `/v2/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new subscription, or updates an existing subscription
         * @summary Adds/updates a subscription
         * @param {SubscriberDto} subscriberDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription: async (subscriberDto: SubscriberDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriberDto' is not null or undefined
            if (subscriberDto === null || subscriberDto === undefined) {
                throw new RequiredError('subscriberDto','Required parameter subscriberDto was null or undefined when calling createSubscription.');
            }
            const localVarPath = `/v2/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof subscriberDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(subscriberDto !== undefined ? subscriberDto : {})
                : (subscriberDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all subscriptions
         * @summary Retrieves all registered subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubscriptionsWrapped: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Date/time needs to be in zulu time with format yyyy-MM-ddTHH:mm:ss
         * @summary Retrieves all ledger entries from specified date/time regardless of event type
         * @param {string} [sinceDateTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSinceDateWrapped: async (sinceDateTime?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/subscriptions/events/replay`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sinceDateTime !== undefined) {
                localVarQueryParameter['sinceDateTime'] = sinceDateTime;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Simply provide a list of type EventInfoDto containing the event types and the LAST event count received for that event. The returned list will contain, as its start point, the point in time at which the oldest of those event types(s)/event count(s) occurred at - the remainder of that list will be event entries containing only events specified in the request body. Note the event count(s) provided should be equal to the actual count received from Common.  This endpoint will know to return events from that count + 1.
         * @summary Retrieves all ledger entries from specified event count(s) and event types(s)
         * @param {Array<EventInfoDto>} eventInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsSinceCountAndTypeWrapped: async (eventInfoDto: Array<EventInfoDto>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventInfoDto' is not null or undefined
            if (eventInfoDto === null || eventInfoDto === undefined) {
                throw new RequiredError('eventInfoDto','Required parameter eventInfoDto was null or undefined when calling getEventsSinceCountAndTypeWrapped.');
            }
            const localVarPath = `/v2/subscriptions/events/replay-events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof eventInfoDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(eventInfoDto !== undefined ? eventInfoDto : {})
                : (eventInfoDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves latest counts for each event type in a key-value pair object
         * @summary Retrieves most current counts for each event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestCountsWrapped: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/subscriptions/events/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a subscription by its UUID
         * @summary Retrieves a registered subscription
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSubscription.');
            }
            const localVarPath = `/v2/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriberControllerApi - functional programming interface
 * @export
 */
export const SubscriberControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a subscription by its UUID
         * @summary Deletes a subscription
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSubscription(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriberDto>> {
            const localVarAxiosArgs = await SubscriberControllerApiAxiosParamCreator(configuration).cancelSubscription(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adds a new subscription, or updates an existing subscription
         * @summary Adds/updates a subscription
         * @param {SubscriberDto} subscriberDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscription(subscriberDto: SubscriberDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriberDto>> {
            const localVarAxiosArgs = await SubscriberControllerApiAxiosParamCreator(configuration).createSubscription(subscriberDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves all subscriptions
         * @summary Retrieves all registered subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSubscriptionsWrapped(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriberDtoResponseWrapper>> {
            const localVarAxiosArgs = await SubscriberControllerApiAxiosParamCreator(configuration).getAllSubscriptionsWrapped(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Date/time needs to be in zulu time with format yyyy-MM-ddTHH:mm:ss
         * @summary Retrieves all ledger entries from specified date/time regardless of event type
         * @param {string} [sinceDateTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventSinceDateWrapped(sinceDateTime?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PubSubLedgerEntryDtoResponseWrapper>> {
            const localVarAxiosArgs = await SubscriberControllerApiAxiosParamCreator(configuration).getEventSinceDateWrapped(sinceDateTime, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Simply provide a list of type EventInfoDto containing the event types and the LAST event count received for that event. The returned list will contain, as its start point, the point in time at which the oldest of those event types(s)/event count(s) occurred at - the remainder of that list will be event entries containing only events specified in the request body. Note the event count(s) provided should be equal to the actual count received from Common.  This endpoint will know to return events from that count + 1.
         * @summary Retrieves all ledger entries from specified event count(s) and event types(s)
         * @param {Array<EventInfoDto>} eventInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventsSinceCountAndTypeWrapped(eventInfoDto: Array<EventInfoDto>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PubSubLedgerEntryDtoResponseWrapper>> {
            const localVarAxiosArgs = await SubscriberControllerApiAxiosParamCreator(configuration).getEventsSinceCountAndTypeWrapped(eventInfoDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves latest counts for each event type in a key-value pair object
         * @summary Retrieves most current counts for each event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestCountsWrapped(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventInfoDtoResponseWrapper>> {
            const localVarAxiosArgs = await SubscriberControllerApiAxiosParamCreator(configuration).getLatestCountsWrapped(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a subscription by its UUID
         * @summary Retrieves a registered subscription
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscription(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriberDto>> {
            const localVarAxiosArgs = await SubscriberControllerApiAxiosParamCreator(configuration).getSubscription(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SubscriberControllerApi - factory interface
 * @export
 */
export const SubscriberControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Deletes a subscription by its UUID
         * @summary Deletes a subscription
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscription(id: string, options?: any): AxiosPromise<SubscriberDto> {
            return SubscriberControllerApiFp(configuration).cancelSubscription(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new subscription, or updates an existing subscription
         * @summary Adds/updates a subscription
         * @param {SubscriberDto} subscriberDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(subscriberDto: SubscriberDto, options?: any): AxiosPromise<SubscriberDto> {
            return SubscriberControllerApiFp(configuration).createSubscription(subscriberDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all subscriptions
         * @summary Retrieves all registered subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubscriptionsWrapped(options?: any): AxiosPromise<SubscriberDtoResponseWrapper> {
            return SubscriberControllerApiFp(configuration).getAllSubscriptionsWrapped(options).then((request) => request(axios, basePath));
        },
        /**
         * Date/time needs to be in zulu time with format yyyy-MM-ddTHH:mm:ss
         * @summary Retrieves all ledger entries from specified date/time regardless of event type
         * @param {string} [sinceDateTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSinceDateWrapped(sinceDateTime?: string, options?: any): AxiosPromise<PubSubLedgerEntryDtoResponseWrapper> {
            return SubscriberControllerApiFp(configuration).getEventSinceDateWrapped(sinceDateTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Simply provide a list of type EventInfoDto containing the event types and the LAST event count received for that event. The returned list will contain, as its start point, the point in time at which the oldest of those event types(s)/event count(s) occurred at - the remainder of that list will be event entries containing only events specified in the request body. Note the event count(s) provided should be equal to the actual count received from Common.  This endpoint will know to return events from that count + 1.
         * @summary Retrieves all ledger entries from specified event count(s) and event types(s)
         * @param {Array<EventInfoDto>} eventInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsSinceCountAndTypeWrapped(eventInfoDto: Array<EventInfoDto>, options?: any): AxiosPromise<PubSubLedgerEntryDtoResponseWrapper> {
            return SubscriberControllerApiFp(configuration).getEventsSinceCountAndTypeWrapped(eventInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves latest counts for each event type in a key-value pair object
         * @summary Retrieves most current counts for each event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestCountsWrapped(options?: any): AxiosPromise<EventInfoDtoResponseWrapper> {
            return SubscriberControllerApiFp(configuration).getLatestCountsWrapped(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a subscription by its UUID
         * @summary Retrieves a registered subscription
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(id: string, options?: any): AxiosPromise<SubscriberDto> {
            return SubscriberControllerApiFp(configuration).getSubscription(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriberControllerApi - interface
 * @export
 * @interface SubscriberControllerApi
 */
export interface SubscriberControllerApiInterface {
    /**
     * Deletes a subscription by its UUID
     * @summary Deletes a subscription
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberControllerApiInterface
     */
    cancelSubscription(id: string, options?: any): AxiosPromise<SubscriberDto>;

    /**
     * Adds a new subscription, or updates an existing subscription
     * @summary Adds/updates a subscription
     * @param {SubscriberDto} subscriberDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberControllerApiInterface
     */
    createSubscription(subscriberDto: SubscriberDto, options?: any): AxiosPromise<SubscriberDto>;

    /**
     * Retrieves all subscriptions
     * @summary Retrieves all registered subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberControllerApiInterface
     */
    getAllSubscriptionsWrapped(options?: any): AxiosPromise<SubscriberDtoResponseWrapper>;

    /**
     * Date/time needs to be in zulu time with format yyyy-MM-ddTHH:mm:ss
     * @summary Retrieves all ledger entries from specified date/time regardless of event type
     * @param {string} [sinceDateTime] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberControllerApiInterface
     */
    getEventSinceDateWrapped(sinceDateTime?: string, options?: any): AxiosPromise<PubSubLedgerEntryDtoResponseWrapper>;

    /**
     * Simply provide a list of type EventInfoDto containing the event types and the LAST event count received for that event. The returned list will contain, as its start point, the point in time at which the oldest of those event types(s)/event count(s) occurred at - the remainder of that list will be event entries containing only events specified in the request body. Note the event count(s) provided should be equal to the actual count received from Common.  This endpoint will know to return events from that count + 1.
     * @summary Retrieves all ledger entries from specified event count(s) and event types(s)
     * @param {Array<EventInfoDto>} eventInfoDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberControllerApiInterface
     */
    getEventsSinceCountAndTypeWrapped(eventInfoDto: Array<EventInfoDto>, options?: any): AxiosPromise<PubSubLedgerEntryDtoResponseWrapper>;

    /**
     * Retrieves latest counts for each event type in a key-value pair object
     * @summary Retrieves most current counts for each event type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberControllerApiInterface
     */
    getLatestCountsWrapped(options?: any): AxiosPromise<EventInfoDtoResponseWrapper>;

    /**
     * Retrieve a subscription by its UUID
     * @summary Retrieves a registered subscription
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberControllerApiInterface
     */
    getSubscription(id: string, options?: any): AxiosPromise<SubscriberDto>;

}

/**
 * SubscriberControllerApi - object-oriented interface
 * @export
 * @class SubscriberControllerApi
 * @extends {BaseAPI}
 */
export class SubscriberControllerApi extends BaseAPI implements SubscriberControllerApiInterface {
    /**
     * Deletes a subscription by its UUID
     * @summary Deletes a subscription
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberControllerApi
     */
    public cancelSubscription(id: string, options?: any) {
        return SubscriberControllerApiFp(this.configuration).cancelSubscription(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new subscription, or updates an existing subscription
     * @summary Adds/updates a subscription
     * @param {SubscriberDto} subscriberDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberControllerApi
     */
    public createSubscription(subscriberDto: SubscriberDto, options?: any) {
        return SubscriberControllerApiFp(this.configuration).createSubscription(subscriberDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all subscriptions
     * @summary Retrieves all registered subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberControllerApi
     */
    public getAllSubscriptionsWrapped(options?: any) {
        return SubscriberControllerApiFp(this.configuration).getAllSubscriptionsWrapped(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Date/time needs to be in zulu time with format yyyy-MM-ddTHH:mm:ss
     * @summary Retrieves all ledger entries from specified date/time regardless of event type
     * @param {string} [sinceDateTime] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberControllerApi
     */
    public getEventSinceDateWrapped(sinceDateTime?: string, options?: any) {
        return SubscriberControllerApiFp(this.configuration).getEventSinceDateWrapped(sinceDateTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simply provide a list of type EventInfoDto containing the event types and the LAST event count received for that event. The returned list will contain, as its start point, the point in time at which the oldest of those event types(s)/event count(s) occurred at - the remainder of that list will be event entries containing only events specified in the request body. Note the event count(s) provided should be equal to the actual count received from Common.  This endpoint will know to return events from that count + 1.
     * @summary Retrieves all ledger entries from specified event count(s) and event types(s)
     * @param {Array<EventInfoDto>} eventInfoDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberControllerApi
     */
    public getEventsSinceCountAndTypeWrapped(eventInfoDto: Array<EventInfoDto>, options?: any) {
        return SubscriberControllerApiFp(this.configuration).getEventsSinceCountAndTypeWrapped(eventInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves latest counts for each event type in a key-value pair object
     * @summary Retrieves most current counts for each event type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberControllerApi
     */
    public getLatestCountsWrapped(options?: any) {
        return SubscriberControllerApiFp(this.configuration).getLatestCountsWrapped(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a subscription by its UUID
     * @summary Retrieves a registered subscription
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberControllerApi
     */
    public getSubscription(id: string, options?: any) {
        return SubscriberControllerApiFp(this.configuration).getSubscription(id, options).then((request) => request(this.axios, this.basePath));
    }
}
