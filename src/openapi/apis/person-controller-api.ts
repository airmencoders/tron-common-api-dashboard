/* tslint:disable */
/* eslint-disable */
/**
 * TRON Common API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { Airman } from '../models';
// @ts-ignore
import { CoastGuardsman } from '../models';
// @ts-ignore
import { ExceptionResponse } from '../models';
// @ts-ignore
import { FilterDto } from '../models';
// @ts-ignore
import { JsonPatchObjectArrayValue } from '../models';
// @ts-ignore
import { JsonPatchObjectValue } from '../models';
// @ts-ignore
import { JsonPatchStringArrayValue } from '../models';
// @ts-ignore
import { JsonPatchStringValue } from '../models';
// @ts-ignore
import { Marine } from '../models';
// @ts-ignore
import { PersonDto } from '../models';
// @ts-ignore
import { PersonDtoPaginationResponseWrapper } from '../models';
// @ts-ignore
import { PersonDtoResponseWrapper } from '../models';
// @ts-ignore
import { PersonFindDto } from '../models';
// @ts-ignore
import { PlatformJwtDto } from '../models';
// @ts-ignore
import { Sailor } from '../models';
// @ts-ignore
import { Soldier } from '../models';
// @ts-ignore
import { Spaceman } from '../models';
/**
 * PersonControllerApi - axios parameter creator
 * @export
 */
export const PersonControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds one or more person entities - returns that same array of input persons with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new persons will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
         * @summary Add one or more members to the database
         * @param {Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>} personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPersonsWrapped: async (personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman: Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman' is not null or undefined
            if (personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman === null || personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman === undefined) {
                throw new RequiredError('personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman','Required parameter personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman was null or undefined when calling addPersonsWrapped.');
            }
            const localVarPath = `/v2/person/persons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman !== undefined ? personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman : {})
                : (personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a person.  Query Ranks controller for available Ranks and Branches. If a given Rank or Branch is invalid, the Person will be created with rank \'Unknown\' and branch \'Other\'
         * @summary Adds a person
         * @param {PersonDto} personDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerson: async (personDto: PersonDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'personDto' is not null or undefined
            if (personDto === null || personDto === undefined) {
                throw new RequiredError('personDto','Required parameter personDto was null or undefined when calling createPerson.');
            }
            const localVarPath = `/v2/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof personDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(personDto !== undefined ? personDto : {})
                : (personDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a person using info from P1 JWT
         * @param {PlatformJwtDto} platformJwtDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonFromJwt: async (platformJwtDto: PlatformJwtDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'platformJwtDto' is not null or undefined
            if (platformJwtDto === null || platformJwtDto === undefined) {
                throw new RequiredError('platformJwtDto','Required parameter platformJwtDto was null or undefined when calling createPersonFromJwt.');
            }
            const localVarPath = `/v2/person/person-jwt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof platformJwtDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(platformJwtDto !== undefined ? platformJwtDto : {})
                : (platformJwtDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing person
         * @summary Deletes an existing person
         * @param {string} id Person ID to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerson: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePerson.');
            }
            const localVarPath = `/v2/person/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves filtered list of persons
         * @summary Retrieves persons filtered
         * @param {FilterDto} filterDto 
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterPerson: async (filterDto: FilterDto, memberships?: boolean, leaderships?: boolean, page?: number, size?: number, sort?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'filterDto' is not null or undefined
            if (filterDto === null || filterDto === undefined) {
                throw new RequiredError('filterDto','Required parameter filterDto was null or undefined when calling filterPerson.');
            }
            const localVarPath = `/v2/person/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (memberships !== undefined) {
                localVarQueryParameter['memberships'] = memberships;
            }

            if (leaderships !== undefined) {
                localVarQueryParameter['leaderships'] = leaderships;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof filterDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(filterDto !== undefined ? filterDto : {})
                : (filterDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a person using a single identifying property.
         * @summary Retrieves a person by email or dodid
         * @param {PersonFindDto} personFindDto 
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPersonBy: async (personFindDto: PersonFindDto, memberships?: boolean, leaderships?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'personFindDto' is not null or undefined
            if (personFindDto === null || personFindDto === undefined) {
                throw new RequiredError('personFindDto','Required parameter personFindDto was null or undefined when calling findPersonBy.');
            }
            const localVarPath = `/v2/person/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (memberships !== undefined) {
                localVarQueryParameter['memberships'] = memberships;
            }

            if (leaderships !== undefined) {
                localVarQueryParameter['leaderships'] = leaderships;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof personFindDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(personFindDto !== undefined ? personFindDto : {})
                : (personFindDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a person by ID
         * @summary Retrieves a person by ID
         * @param {string} id Person ID to retrieve
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson: async (id: string, memberships?: boolean, leaderships?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPerson.');
            }
            const localVarPath = `/v2/person/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (memberships !== undefined) {
                localVarQueryParameter['memberships'] = memberships;
            }

            if (leaderships !== undefined) {
                localVarQueryParameter['leaderships'] = leaderships;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all persons  with pagination information
         * @summary Retrieves all persons
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonsWrapped: async (memberships?: boolean, leaderships?: boolean, page?: number, size?: number, sort?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (memberships !== undefined) {
                localVarQueryParameter['memberships'] = memberships;
            }

            if (leaderships !== undefined) {
                localVarQueryParameter['leaderships'] = leaderships;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Patches an existing person
         * @summary Patches an existing person
         * @param {string} id Person ID to patch
         * @param {JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue} jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchPerson: async (id: string, jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue: JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling patchPerson.');
            }
            // verify required parameter 'jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue' is not null or undefined
            if (jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue === null || jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue === undefined) {
                throw new RequiredError('jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue','Required parameter jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue was null or undefined when calling patchPerson.');
            }
            const localVarPath = `/v2/person/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue !== undefined ? jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue : {})
                : (jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * The email from the updated Person record must match the email in the authenticated user\'s JWT, otherwise this action will be rejected.  Request must be from the web (SSO) and not an app client.
         * @summary Allows a Person to update their own existing record.
         * @param {PersonDto} personDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selfUpdatePerson: async (personDto: PersonDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'personDto' is not null or undefined
            if (personDto === null || personDto === undefined) {
                throw new RequiredError('personDto','Required parameter personDto was null or undefined when calling selfUpdatePerson.');
            }
            const localVarPath = `/v2/person/self`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof personDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(personDto !== undefined ? personDto : {})
                : (personDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing person
         * @summary Updates an existing person
         * @param {string} id Person ID to update
         * @param {PersonDto} personDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson: async (id: string, personDto: PersonDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePerson.');
            }
            // verify required parameter 'personDto' is not null or undefined
            if (personDto === null || personDto === undefined) {
                throw new RequiredError('personDto','Required parameter personDto was null or undefined when calling updatePerson.');
            }
            const localVarPath = `/v2/person/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof personDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(personDto !== undefined ? personDto : {})
                : (personDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonControllerApi - functional programming interface
 * @export
 */
export const PersonControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds one or more person entities - returns that same array of input persons with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new persons will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
         * @summary Add one or more members to the database
         * @param {Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>} personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPersonsWrapped(personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman: Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonDtoResponseWrapper>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).addPersonsWrapped(personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adds a person.  Query Ranks controller for available Ranks and Branches. If a given Rank or Branch is invalid, the Person will be created with rank \'Unknown\' and branch \'Other\'
         * @summary Adds a person
         * @param {PersonDto} personDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPerson(personDto: PersonDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonDto>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).createPerson(personDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Adds a person using info from P1 JWT
         * @param {PlatformJwtDto} platformJwtDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPersonFromJwt(platformJwtDto: PlatformJwtDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonDto>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).createPersonFromJwt(platformJwtDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an existing person
         * @summary Deletes an existing person
         * @param {string} id Person ID to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePerson(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).deletePerson(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves filtered list of persons
         * @summary Retrieves persons filtered
         * @param {FilterDto} filterDto 
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filterPerson(filterDto: FilterDto, memberships?: boolean, leaderships?: boolean, page?: number, size?: number, sort?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonDtoPaginationResponseWrapper>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).filterPerson(filterDto, memberships, leaderships, page, size, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves a person using a single identifying property.
         * @summary Retrieves a person by email or dodid
         * @param {PersonFindDto} personFindDto 
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPersonBy(personFindDto: PersonFindDto, memberships?: boolean, leaderships?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonDto>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).findPersonBy(personFindDto, memberships, leaderships, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves a person by ID
         * @summary Retrieves a person by ID
         * @param {string} id Person ID to retrieve
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPerson(id: string, memberships?: boolean, leaderships?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonDto>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).getPerson(id, memberships, leaderships, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves all persons  with pagination information
         * @summary Retrieves all persons
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonsWrapped(memberships?: boolean, leaderships?: boolean, page?: number, size?: number, sort?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonDtoPaginationResponseWrapper>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).getPersonsWrapped(memberships, leaderships, page, size, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Patches an existing person
         * @summary Patches an existing person
         * @param {string} id Person ID to patch
         * @param {JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue} jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchPerson(id: string, jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue: JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonDto>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).patchPerson(id, jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The email from the updated Person record must match the email in the authenticated user\'s JWT, otherwise this action will be rejected.  Request must be from the web (SSO) and not an app client.
         * @summary Allows a Person to update their own existing record.
         * @param {PersonDto} personDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async selfUpdatePerson(personDto: PersonDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonDto>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).selfUpdatePerson(personDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an existing person
         * @summary Updates an existing person
         * @param {string} id Person ID to update
         * @param {PersonDto} personDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePerson(id: string, personDto: PersonDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonDto>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).updatePerson(id, personDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PersonControllerApi - factory interface
 * @export
 */
export const PersonControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adds one or more person entities - returns that same array of input persons with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new persons will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
         * @summary Add one or more members to the database
         * @param {Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>} personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPersonsWrapped(personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman: Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>, options?: any): AxiosPromise<PersonDtoResponseWrapper> {
            return PersonControllerApiFp(configuration).addPersonsWrapped(personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a person.  Query Ranks controller for available Ranks and Branches. If a given Rank or Branch is invalid, the Person will be created with rank \'Unknown\' and branch \'Other\'
         * @summary Adds a person
         * @param {PersonDto} personDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerson(personDto: PersonDto, options?: any): AxiosPromise<PersonDto> {
            return PersonControllerApiFp(configuration).createPerson(personDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a person using info from P1 JWT
         * @param {PlatformJwtDto} platformJwtDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonFromJwt(platformJwtDto: PlatformJwtDto, options?: any): AxiosPromise<PersonDto> {
            return PersonControllerApiFp(configuration).createPersonFromJwt(platformJwtDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing person
         * @summary Deletes an existing person
         * @param {string} id Person ID to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerson(id: string, options?: any): AxiosPromise<void> {
            return PersonControllerApiFp(configuration).deletePerson(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves filtered list of persons
         * @summary Retrieves persons filtered
         * @param {FilterDto} filterDto 
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterPerson(filterDto: FilterDto, memberships?: boolean, leaderships?: boolean, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PersonDtoPaginationResponseWrapper> {
            return PersonControllerApiFp(configuration).filterPerson(filterDto, memberships, leaderships, page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a person using a single identifying property.
         * @summary Retrieves a person by email or dodid
         * @param {PersonFindDto} personFindDto 
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPersonBy(personFindDto: PersonFindDto, memberships?: boolean, leaderships?: boolean, options?: any): AxiosPromise<PersonDto> {
            return PersonControllerApiFp(configuration).findPersonBy(personFindDto, memberships, leaderships, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a person by ID
         * @summary Retrieves a person by ID
         * @param {string} id Person ID to retrieve
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson(id: string, memberships?: boolean, leaderships?: boolean, options?: any): AxiosPromise<PersonDto> {
            return PersonControllerApiFp(configuration).getPerson(id, memberships, leaderships, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all persons  with pagination information
         * @summary Retrieves all persons
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonsWrapped(memberships?: boolean, leaderships?: boolean, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PersonDtoPaginationResponseWrapper> {
            return PersonControllerApiFp(configuration).getPersonsWrapped(memberships, leaderships, page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Patches an existing person
         * @summary Patches an existing person
         * @param {string} id Person ID to patch
         * @param {JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue} jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchPerson(id: string, jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue: JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue, options?: any): AxiosPromise<PersonDto> {
            return PersonControllerApiFp(configuration).patchPerson(id, jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue, options).then((request) => request(axios, basePath));
        },
        /**
         * The email from the updated Person record must match the email in the authenticated user\'s JWT, otherwise this action will be rejected.  Request must be from the web (SSO) and not an app client.
         * @summary Allows a Person to update their own existing record.
         * @param {PersonDto} personDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selfUpdatePerson(personDto: PersonDto, options?: any): AxiosPromise<PersonDto> {
            return PersonControllerApiFp(configuration).selfUpdatePerson(personDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing person
         * @summary Updates an existing person
         * @param {string} id Person ID to update
         * @param {PersonDto} personDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson(id: string, personDto: PersonDto, options?: any): AxiosPromise<PersonDto> {
            return PersonControllerApiFp(configuration).updatePerson(id, personDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonControllerApi - interface
 * @export
 * @interface PersonControllerApi
 */
export interface PersonControllerApiInterface {
    /**
     * Adds one or more person entities - returns that same array of input persons with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new persons will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
     * @summary Add one or more members to the database
     * @param {Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>} personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    addPersonsWrapped(personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman: Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>, options?: any): AxiosPromise<PersonDtoResponseWrapper>;

    /**
     * Adds a person.  Query Ranks controller for available Ranks and Branches. If a given Rank or Branch is invalid, the Person will be created with rank \'Unknown\' and branch \'Other\'
     * @summary Adds a person
     * @param {PersonDto} personDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    createPerson(personDto: PersonDto, options?: any): AxiosPromise<PersonDto>;

    /**
     * 
     * @summary Adds a person using info from P1 JWT
     * @param {PlatformJwtDto} platformJwtDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    createPersonFromJwt(platformJwtDto: PlatformJwtDto, options?: any): AxiosPromise<PersonDto>;

    /**
     * Deletes an existing person
     * @summary Deletes an existing person
     * @param {string} id Person ID to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    deletePerson(id: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves filtered list of persons
     * @summary Retrieves persons filtered
     * @param {FilterDto} filterDto 
     * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
     * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    filterPerson(filterDto: FilterDto, memberships?: boolean, leaderships?: boolean, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PersonDtoPaginationResponseWrapper>;

    /**
     * Retrieves a person using a single identifying property.
     * @summary Retrieves a person by email or dodid
     * @param {PersonFindDto} personFindDto 
     * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
     * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    findPersonBy(personFindDto: PersonFindDto, memberships?: boolean, leaderships?: boolean, options?: any): AxiosPromise<PersonDto>;

    /**
     * Retrieves a person by ID
     * @summary Retrieves a person by ID
     * @param {string} id Person ID to retrieve
     * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
     * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    getPerson(id: string, memberships?: boolean, leaderships?: boolean, options?: any): AxiosPromise<PersonDto>;

    /**
     * Retrieves all persons  with pagination information
     * @summary Retrieves all persons
     * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
     * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    getPersonsWrapped(memberships?: boolean, leaderships?: boolean, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PersonDtoPaginationResponseWrapper>;

    /**
     * Patches an existing person
     * @summary Patches an existing person
     * @param {string} id Person ID to patch
     * @param {JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue} jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    patchPerson(id: string, jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue: JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue, options?: any): AxiosPromise<PersonDto>;

    /**
     * The email from the updated Person record must match the email in the authenticated user\'s JWT, otherwise this action will be rejected.  Request must be from the web (SSO) and not an app client.
     * @summary Allows a Person to update their own existing record.
     * @param {PersonDto} personDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    selfUpdatePerson(personDto: PersonDto, options?: any): AxiosPromise<PersonDto>;

    /**
     * Updates an existing person
     * @summary Updates an existing person
     * @param {string} id Person ID to update
     * @param {PersonDto} personDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    updatePerson(id: string, personDto: PersonDto, options?: any): AxiosPromise<PersonDto>;

}

/**
 * PersonControllerApi - object-oriented interface
 * @export
 * @class PersonControllerApi
 * @extends {BaseAPI}
 */
export class PersonControllerApi extends BaseAPI implements PersonControllerApiInterface {
    /**
     * Adds one or more person entities - returns that same array of input persons with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new persons will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
     * @summary Add one or more members to the database
     * @param {Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>} personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public addPersonsWrapped(personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman: Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>, options?: any) {
        return PersonControllerApiFp(this.configuration).addPersonsWrapped(personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a person.  Query Ranks controller for available Ranks and Branches. If a given Rank or Branch is invalid, the Person will be created with rank \'Unknown\' and branch \'Other\'
     * @summary Adds a person
     * @param {PersonDto} personDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public createPerson(personDto: PersonDto, options?: any) {
        return PersonControllerApiFp(this.configuration).createPerson(personDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a person using info from P1 JWT
     * @param {PlatformJwtDto} platformJwtDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public createPersonFromJwt(platformJwtDto: PlatformJwtDto, options?: any) {
        return PersonControllerApiFp(this.configuration).createPersonFromJwt(platformJwtDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing person
     * @summary Deletes an existing person
     * @param {string} id Person ID to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public deletePerson(id: string, options?: any) {
        return PersonControllerApiFp(this.configuration).deletePerson(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves filtered list of persons
     * @summary Retrieves persons filtered
     * @param {FilterDto} filterDto 
     * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
     * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public filterPerson(filterDto: FilterDto, memberships?: boolean, leaderships?: boolean, page?: number, size?: number, sort?: Array<string>, options?: any) {
        return PersonControllerApiFp(this.configuration).filterPerson(filterDto, memberships, leaderships, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a person using a single identifying property.
     * @summary Retrieves a person by email or dodid
     * @param {PersonFindDto} personFindDto 
     * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
     * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public findPersonBy(personFindDto: PersonFindDto, memberships?: boolean, leaderships?: boolean, options?: any) {
        return PersonControllerApiFp(this.configuration).findPersonBy(personFindDto, memberships, leaderships, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a person by ID
     * @summary Retrieves a person by ID
     * @param {string} id Person ID to retrieve
     * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
     * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public getPerson(id: string, memberships?: boolean, leaderships?: boolean, options?: any) {
        return PersonControllerApiFp(this.configuration).getPerson(id, memberships, leaderships, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all persons  with pagination information
     * @summary Retrieves all persons
     * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
     * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public getPersonsWrapped(memberships?: boolean, leaderships?: boolean, page?: number, size?: number, sort?: Array<string>, options?: any) {
        return PersonControllerApiFp(this.configuration).getPersonsWrapped(memberships, leaderships, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patches an existing person
     * @summary Patches an existing person
     * @param {string} id Person ID to patch
     * @param {JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue} jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public patchPerson(id: string, jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue: JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue, options?: any) {
        return PersonControllerApiFp(this.configuration).patchPerson(id, jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The email from the updated Person record must match the email in the authenticated user\'s JWT, otherwise this action will be rejected.  Request must be from the web (SSO) and not an app client.
     * @summary Allows a Person to update their own existing record.
     * @param {PersonDto} personDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public selfUpdatePerson(personDto: PersonDto, options?: any) {
        return PersonControllerApiFp(this.configuration).selfUpdatePerson(personDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing person
     * @summary Updates an existing person
     * @param {string} id Person ID to update
     * @param {PersonDto} personDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public updatePerson(id: string, personDto: PersonDto, options?: any) {
        return PersonControllerApiFp(this.configuration).updatePerson(id, personDto, options).then((request) => request(this.axios, this.basePath));
    }
}
