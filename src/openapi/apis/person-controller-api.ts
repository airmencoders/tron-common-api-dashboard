/* tslint:disable */
/* eslint-disable */
/**
 * TRON Common API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ExceptionResponse } from '../models';
// @ts-ignore
import { Person } from '../models';
/**
 * PersonControllerApi - axios parameter creator
 * @export
 */
export const PersonControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds one or more person entities - returns that same array of input persons with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new persons will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
         * @summary Add one or more members to the database
         * @param {Array<Person>} person 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPersons: async (person: Array<Person>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'person' is not null or undefined
            if (person === null || person === undefined) {
                throw new RequiredError('person','Required parameter person was null or undefined when calling addPersons.');
            }
            const localVarPath = `/v1/person/persons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof person !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(person !== undefined ? person : {})
                : (person || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a person
         * @summary Adds a person
         * @param {Person} person 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerson: async (person: Person, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'person' is not null or undefined
            if (person === null || person === undefined) {
                throw new RequiredError('person','Required parameter person was null or undefined when calling createPerson.');
            }
            const localVarPath = `/v1/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof person !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(person !== undefined ? person : {})
                : (person || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing person
         * @summary Deletes an existing person
         * @param {string} id Person ID to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerson: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePerson.');
            }
            const localVarPath = `/v1/person/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a person by ID
         * @summary Retrieves a person by ID
         * @param {string} id Person ID to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPerson.');
            }
            const localVarPath = `/v1/person/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all persons
         * @summary Retrieves all persons
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersons: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing person
         * @summary Updates an existing person
         * @param {string} id Person ID to update
         * @param {Person} person 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson: async (id: string, person: Person, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePerson.');
            }
            // verify required parameter 'person' is not null or undefined
            if (person === null || person === undefined) {
                throw new RequiredError('person','Required parameter person was null or undefined when calling updatePerson.');
            }
            const localVarPath = `/v1/person/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof person !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(person !== undefined ? person : {})
                : (person || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonControllerApi - functional programming interface
 * @export
 */
export const PersonControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds one or more person entities - returns that same array of input persons with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new persons will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
         * @summary Add one or more members to the database
         * @param {Array<Person>} person 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPersons(person: Array<Person>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Person>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).addPersons(person, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adds a person
         * @summary Adds a person
         * @param {Person} person 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPerson(person: Person, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Person>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).createPerson(person, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an existing person
         * @summary Deletes an existing person
         * @param {string} id Person ID to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePerson(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).deletePerson(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves a person by ID
         * @summary Retrieves a person by ID
         * @param {string} id Person ID to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPerson(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Person>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).getPerson(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves all persons
         * @summary Retrieves all persons
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersons(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Person>>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).getPersons(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an existing person
         * @summary Updates an existing person
         * @param {string} id Person ID to update
         * @param {Person} person 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePerson(id: string, person: Person, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Person>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).updatePerson(id, person, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PersonControllerApi - factory interface
 * @export
 */
export const PersonControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adds one or more person entities - returns that same array of input persons with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new persons will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
         * @summary Add one or more members to the database
         * @param {Array<Person>} person 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPersons(person: Array<Person>, options?: any): AxiosPromise<Person> {
            return PersonControllerApiFp(configuration).addPersons(person, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a person
         * @summary Adds a person
         * @param {Person} person 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerson(person: Person, options?: any): AxiosPromise<Person> {
            return PersonControllerApiFp(configuration).createPerson(person, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing person
         * @summary Deletes an existing person
         * @param {string} id Person ID to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerson(id: string, options?: any): AxiosPromise<void> {
            return PersonControllerApiFp(configuration).deletePerson(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a person by ID
         * @summary Retrieves a person by ID
         * @param {string} id Person ID to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson(id: string, options?: any): AxiosPromise<Person> {
            return PersonControllerApiFp(configuration).getPerson(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all persons
         * @summary Retrieves all persons
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersons(options?: any): AxiosPromise<Array<Person>> {
            return PersonControllerApiFp(configuration).getPersons(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing person
         * @summary Updates an existing person
         * @param {string} id Person ID to update
         * @param {Person} person 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson(id: string, person: Person, options?: any): AxiosPromise<Person> {
            return PersonControllerApiFp(configuration).updatePerson(id, person, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonControllerApi - interface
 * @export
 * @interface PersonControllerApi
 */
export interface PersonControllerApiInterface {
    /**
     * Adds one or more person entities - returns that same array of input persons with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new persons will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
     * @summary Add one or more members to the database
     * @param {Array<Person>} person 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    addPersons(person: Array<Person>, options?: any): AxiosPromise<Person>;

    /**
     * Adds a person
     * @summary Adds a person
     * @param {Person} person 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    createPerson(person: Person, options?: any): AxiosPromise<Person>;

    /**
     * Deletes an existing person
     * @summary Deletes an existing person
     * @param {string} id Person ID to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    deletePerson(id: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves a person by ID
     * @summary Retrieves a person by ID
     * @param {string} id Person ID to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    getPerson(id: string, options?: any): AxiosPromise<Person>;

    /**
     * Retrieves all persons
     * @summary Retrieves all persons
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    getPersons(options?: any): AxiosPromise<Array<Person>>;

    /**
     * Updates an existing person
     * @summary Updates an existing person
     * @param {string} id Person ID to update
     * @param {Person} person 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    updatePerson(id: string, person: Person, options?: any): AxiosPromise<Person>;

}

/**
 * PersonControllerApi - object-oriented interface
 * @export
 * @class PersonControllerApi
 * @extends {BaseAPI}
 */
export class PersonControllerApi extends BaseAPI implements PersonControllerApiInterface {
    /**
     * Adds one or more person entities - returns that same array of input persons with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new persons will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
     * @summary Add one or more members to the database
     * @param {Array<Person>} person 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public addPersons(person: Array<Person>, options?: any) {
        return PersonControllerApiFp(this.configuration).addPersons(person, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a person
     * @summary Adds a person
     * @param {Person} person 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public createPerson(person: Person, options?: any) {
        return PersonControllerApiFp(this.configuration).createPerson(person, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing person
     * @summary Deletes an existing person
     * @param {string} id Person ID to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public deletePerson(id: string, options?: any) {
        return PersonControllerApiFp(this.configuration).deletePerson(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a person by ID
     * @summary Retrieves a person by ID
     * @param {string} id Person ID to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public getPerson(id: string, options?: any) {
        return PersonControllerApiFp(this.configuration).getPerson(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all persons
     * @summary Retrieves all persons
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public getPersons(options?: any) {
        return PersonControllerApiFp(this.configuration).getPersons(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing person
     * @summary Updates an existing person
     * @param {string} id Person ID to update
     * @param {Person} person 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public updatePerson(id: string, person: Person, options?: any) {
        return PersonControllerApiFp(this.configuration).updatePerson(id, person, options).then((request) => request(this.axios, this.basePath));
    }
}
