/* tslint:disable */
/* eslint-disable */
/**
 * TRON Common API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { Airman } from '../models';
// @ts-ignore
import { CoastGuardsman } from '../models';
// @ts-ignore
import { ExceptionResponse } from '../models';
// @ts-ignore
import { JsonPatchObjectArrayValue } from '../models';
// @ts-ignore
import { JsonPatchObjectValue } from '../models';
// @ts-ignore
import { JsonPatchStringArrayValue } from '../models';
// @ts-ignore
import { JsonPatchStringValue } from '../models';
// @ts-ignore
import { Marine } from '../models';
// @ts-ignore
import { PersonDto } from '../models';
// @ts-ignore
import { Sailor } from '../models';
// @ts-ignore
import { Soldier } from '../models';
// @ts-ignore
import { Spaceman } from '../models';
/**
 * PersonControllerApi - axios parameter creator
 * @export
 */
export const PersonControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds one or more person entities - returns that same array of input persons with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new persons will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
         * @summary Add one or more members to the database
         * @param {Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>} personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPersons: async (personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman: Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman' is not null or undefined
            if (personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman === null || personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman === undefined) {
                throw new RequiredError('personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman','Required parameter personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman was null or undefined when calling addPersons.');
            }
            const localVarPath = `/v1/person/persons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman !== undefined ? personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman : {})
                : (personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a person.  Query Ranks controller for available Ranks and Branches. If a given Rank or Branch is invalid, the Person will be created with rank \'Unknown\' and branch \'Other\'
         * @summary Adds a person
         * @param {PersonDto} personDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerson: async (personDto: PersonDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'personDto' is not null or undefined
            if (personDto === null || personDto === undefined) {
                throw new RequiredError('personDto','Required parameter personDto was null or undefined when calling createPerson.');
            }
            const localVarPath = `/v1/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof personDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(personDto !== undefined ? personDto : {})
                : (personDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing person
         * @summary Deletes an existing person
         * @param {string} id Person ID to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerson: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePerson.');
            }
            const localVarPath = `/v1/person/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a person using a single identifying property.
         * @summary Retrieves a person by email or dodid
         * @param {'EMAIL' | 'DODID'} findByField The field to search for
         * @param {string} value The value to search against
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPersonBy: async (findByField: 'EMAIL' | 'DODID', value: string, memberships?: boolean, leaderships?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'findByField' is not null or undefined
            if (findByField === null || findByField === undefined) {
                throw new RequiredError('findByField','Required parameter findByField was null or undefined when calling findPersonBy.');
            }
            // verify required parameter 'value' is not null or undefined
            if (value === null || value === undefined) {
                throw new RequiredError('value','Required parameter value was null or undefined when calling findPersonBy.');
            }
            const localVarPath = `/v1/person/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (memberships !== undefined) {
                localVarQueryParameter['memberships'] = memberships;
            }

            if (leaderships !== undefined) {
                localVarQueryParameter['leaderships'] = leaderships;
            }

            if (findByField !== undefined) {
                localVarQueryParameter['findByField'] = findByField;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a person by ID
         * @summary Retrieves a person by ID
         * @param {string} id Person ID to retrieve
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson: async (id: string, memberships?: boolean, leaderships?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPerson.');
            }
            const localVarPath = `/v1/person/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (memberships !== undefined) {
                localVarQueryParameter['memberships'] = memberships;
            }

            if (leaderships !== undefined) {
                localVarQueryParameter['leaderships'] = leaderships;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all persons
         * @summary Retrieves all persons
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersons: async (memberships?: boolean, leaderships?: boolean, page?: number, size?: number, sort?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (memberships !== undefined) {
                localVarQueryParameter['memberships'] = memberships;
            }

            if (leaderships !== undefined) {
                localVarQueryParameter['leaderships'] = leaderships;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Patches an existing person
         * @summary Patches an existing person
         * @param {string} id Person ID to patch
         * @param {JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue} jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchPerson: async (id: string, jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue: JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling patchPerson.');
            }
            // verify required parameter 'jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue' is not null or undefined
            if (jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue === null || jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue === undefined) {
                throw new RequiredError('jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue','Required parameter jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue was null or undefined when calling patchPerson.');
            }
            const localVarPath = `/v1/person/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue !== undefined ? jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue : {})
                : (jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing person
         * @summary Updates an existing person
         * @param {string} id Person ID to update
         * @param {PersonDto} personDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson: async (id: string, personDto: PersonDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePerson.');
            }
            // verify required parameter 'personDto' is not null or undefined
            if (personDto === null || personDto === undefined) {
                throw new RequiredError('personDto','Required parameter personDto was null or undefined when calling updatePerson.');
            }
            const localVarPath = `/v1/person/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof personDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(personDto !== undefined ? personDto : {})
                : (personDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonControllerApi - functional programming interface
 * @export
 */
export const PersonControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds one or more person entities - returns that same array of input persons with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new persons will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
         * @summary Add one or more members to the database
         * @param {Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>} personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPersons(personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman: Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonDto>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).addPersons(personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adds a person.  Query Ranks controller for available Ranks and Branches. If a given Rank or Branch is invalid, the Person will be created with rank \'Unknown\' and branch \'Other\'
         * @summary Adds a person
         * @param {PersonDto} personDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPerson(personDto: PersonDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonDto>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).createPerson(personDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an existing person
         * @summary Deletes an existing person
         * @param {string} id Person ID to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePerson(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).deletePerson(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves a person using a single identifying property.
         * @summary Retrieves a person by email or dodid
         * @param {'EMAIL' | 'DODID'} findByField The field to search for
         * @param {string} value The value to search against
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPersonBy(findByField: 'EMAIL' | 'DODID', value: string, memberships?: boolean, leaderships?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonDto>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).findPersonBy(findByField, value, memberships, leaderships, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves a person by ID
         * @summary Retrieves a person by ID
         * @param {string} id Person ID to retrieve
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPerson(id: string, memberships?: boolean, leaderships?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonDto>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).getPerson(id, memberships, leaderships, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves all persons
         * @summary Retrieves all persons
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersons(memberships?: boolean, leaderships?: boolean, page?: number, size?: number, sort?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PersonDto>>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).getPersons(memberships, leaderships, page, size, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Patches an existing person
         * @summary Patches an existing person
         * @param {string} id Person ID to patch
         * @param {JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue} jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchPerson(id: string, jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue: JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonDto>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).patchPerson(id, jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an existing person
         * @summary Updates an existing person
         * @param {string} id Person ID to update
         * @param {PersonDto} personDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePerson(id: string, personDto: PersonDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonDto>> {
            const localVarAxiosArgs = await PersonControllerApiAxiosParamCreator(configuration).updatePerson(id, personDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PersonControllerApi - factory interface
 * @export
 */
export const PersonControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adds one or more person entities - returns that same array of input persons with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new persons will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
         * @summary Add one or more members to the database
         * @param {Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>} personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPersons(personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman: Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>, options?: any): AxiosPromise<PersonDto> {
            return PersonControllerApiFp(configuration).addPersons(personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a person.  Query Ranks controller for available Ranks and Branches. If a given Rank or Branch is invalid, the Person will be created with rank \'Unknown\' and branch \'Other\'
         * @summary Adds a person
         * @param {PersonDto} personDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerson(personDto: PersonDto, options?: any): AxiosPromise<PersonDto> {
            return PersonControllerApiFp(configuration).createPerson(personDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing person
         * @summary Deletes an existing person
         * @param {string} id Person ID to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerson(id: string, options?: any): AxiosPromise<void> {
            return PersonControllerApiFp(configuration).deletePerson(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a person using a single identifying property.
         * @summary Retrieves a person by email or dodid
         * @param {'EMAIL' | 'DODID'} findByField The field to search for
         * @param {string} value The value to search against
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPersonBy(findByField: 'EMAIL' | 'DODID', value: string, memberships?: boolean, leaderships?: boolean, options?: any): AxiosPromise<PersonDto> {
            return PersonControllerApiFp(configuration).findPersonBy(findByField, value, memberships, leaderships, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a person by ID
         * @summary Retrieves a person by ID
         * @param {string} id Person ID to retrieve
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson(id: string, memberships?: boolean, leaderships?: boolean, options?: any): AxiosPromise<PersonDto> {
            return PersonControllerApiFp(configuration).getPerson(id, memberships, leaderships, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all persons
         * @summary Retrieves all persons
         * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
         * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersons(memberships?: boolean, leaderships?: boolean, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<Array<PersonDto>> {
            return PersonControllerApiFp(configuration).getPersons(memberships, leaderships, page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Patches an existing person
         * @summary Patches an existing person
         * @param {string} id Person ID to patch
         * @param {JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue} jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchPerson(id: string, jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue: JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue, options?: any): AxiosPromise<PersonDto> {
            return PersonControllerApiFp(configuration).patchPerson(id, jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing person
         * @summary Updates an existing person
         * @param {string} id Person ID to update
         * @param {PersonDto} personDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson(id: string, personDto: PersonDto, options?: any): AxiosPromise<PersonDto> {
            return PersonControllerApiFp(configuration).updatePerson(id, personDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonControllerApi - interface
 * @export
 * @interface PersonControllerApi
 */
export interface PersonControllerApiInterface {
    /**
     * Adds one or more person entities - returns that same array of input persons with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new persons will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
     * @summary Add one or more members to the database
     * @param {Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>} personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    addPersons(personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman: Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>, options?: any): AxiosPromise<PersonDto>;

    /**
     * Adds a person.  Query Ranks controller for available Ranks and Branches. If a given Rank or Branch is invalid, the Person will be created with rank \'Unknown\' and branch \'Other\'
     * @summary Adds a person
     * @param {PersonDto} personDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    createPerson(personDto: PersonDto, options?: any): AxiosPromise<PersonDto>;

    /**
     * Deletes an existing person
     * @summary Deletes an existing person
     * @param {string} id Person ID to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    deletePerson(id: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves a person using a single identifying property.
     * @summary Retrieves a person by email or dodid
     * @param {'EMAIL' | 'DODID'} findByField The field to search for
     * @param {string} value The value to search against
     * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
     * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    findPersonBy(findByField: 'EMAIL' | 'DODID', value: string, memberships?: boolean, leaderships?: boolean, options?: any): AxiosPromise<PersonDto>;

    /**
     * Retrieves a person by ID
     * @summary Retrieves a person by ID
     * @param {string} id Person ID to retrieve
     * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
     * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    getPerson(id: string, memberships?: boolean, leaderships?: boolean, options?: any): AxiosPromise<PersonDto>;

    /**
     * Retrieves all persons
     * @summary Retrieves all persons
     * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
     * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    getPersons(memberships?: boolean, leaderships?: boolean, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<Array<PersonDto>>;

    /**
     * Patches an existing person
     * @summary Patches an existing person
     * @param {string} id Person ID to patch
     * @param {JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue} jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    patchPerson(id: string, jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue: JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue, options?: any): AxiosPromise<PersonDto>;

    /**
     * Updates an existing person
     * @summary Updates an existing person
     * @param {string} id Person ID to update
     * @param {PersonDto} personDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApiInterface
     */
    updatePerson(id: string, personDto: PersonDto, options?: any): AxiosPromise<PersonDto>;

}

/**
 * PersonControllerApi - object-oriented interface
 * @export
 * @class PersonControllerApi
 * @extends {BaseAPI}
 */
export class PersonControllerApi extends BaseAPI implements PersonControllerApiInterface {
    /**
     * Adds one or more person entities - returns that same array of input persons with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new persons will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
     * @summary Add one or more members to the database
     * @param {Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>} personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public addPersons(personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman: Array<PersonDto | Airman | CoastGuardsman | Marine | Sailor | Soldier | Spaceman>, options?: any) {
        return PersonControllerApiFp(this.configuration).addPersons(personDtoAirmanCoastGuardsmanMarineSailorSoldierSpaceman, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a person.  Query Ranks controller for available Ranks and Branches. If a given Rank or Branch is invalid, the Person will be created with rank \'Unknown\' and branch \'Other\'
     * @summary Adds a person
     * @param {PersonDto} personDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public createPerson(personDto: PersonDto, options?: any) {
        return PersonControllerApiFp(this.configuration).createPerson(personDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing person
     * @summary Deletes an existing person
     * @param {string} id Person ID to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public deletePerson(id: string, options?: any) {
        return PersonControllerApiFp(this.configuration).deletePerson(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a person using a single identifying property.
     * @summary Retrieves a person by email or dodid
     * @param {'EMAIL' | 'DODID'} findByField The field to search for
     * @param {string} value The value to search against
     * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
     * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public findPersonBy(findByField: 'EMAIL' | 'DODID', value: string, memberships?: boolean, leaderships?: boolean, options?: any) {
        return PersonControllerApiFp(this.configuration).findPersonBy(findByField, value, memberships, leaderships, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a person by ID
     * @summary Retrieves a person by ID
     * @param {string} id Person ID to retrieve
     * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
     * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public getPerson(id: string, memberships?: boolean, leaderships?: boolean, options?: any) {
        return PersonControllerApiFp(this.configuration).getPerson(id, memberships, leaderships, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all persons
     * @summary Retrieves all persons
     * @param {boolean} [memberships] Whether to include this person\&#39;s organization memberships in the response
     * @param {boolean} [leaderships] Whether to include the organization ids this person is the leader of in the response
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public getPersons(memberships?: boolean, leaderships?: boolean, page?: number, size?: number, sort?: Array<string>, options?: any) {
        return PersonControllerApiFp(this.configuration).getPersons(memberships, leaderships, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patches an existing person
     * @summary Patches an existing person
     * @param {string} id Person ID to patch
     * @param {JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue} jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public patchPerson(id: string, jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue: JsonPatchStringArrayValue | JsonPatchStringValue | JsonPatchObjectValue | JsonPatchObjectArrayValue, options?: any) {
        return PersonControllerApiFp(this.configuration).patchPerson(id, jsonPatchStringArrayValueJsonPatchStringValueJsonPatchObjectValueJsonPatchObjectArrayValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing person
     * @summary Updates an existing person
     * @param {string} id Person ID to update
     * @param {PersonDto} personDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonControllerApi
     */
    public updatePerson(id: string, personDto: PersonDto, options?: any) {
        return PersonControllerApiFp(this.configuration).updatePerson(id, personDto, options).then((request) => request(this.axios, this.basePath));
    }
}
