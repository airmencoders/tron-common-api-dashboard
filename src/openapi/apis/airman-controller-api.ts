/* tslint:disable */
/* eslint-disable */
/**
 * TRON Common API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { Airman } from '../models';
// @ts-ignore
import { ExceptionResponse } from '../models';
/**
 * AirmanControllerApi - axios parameter creator
 * @export
 */
export const AirmanControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new airman, ID field should be null for a new addition.
         * @summary Adds a new airman
         * @param {Airman} airman 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAirman: async (airman: Airman, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'airman' is not null or undefined
            if (airman === null || airman === undefined) {
                throw new RequiredError('airman','Required parameter airman was null or undefined when calling addAirman.');
            }
            const localVarPath = `/v1/airman`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof airman !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(airman !== undefined ? airman : {})
                : (airman || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds one or more airmen entities - returns that same array of input airmen with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new airmen will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
         * @summary Adds one or more airmen entities
         * @param {Array<Airman>} airman 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAirmen: async (airman: Array<Airman>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'airman' is not null or undefined
            if (airman === null || airman === undefined) {
                throw new RequiredError('airman','Required parameter airman was null or undefined when calling addAirmen.');
            }
            const localVarPath = `/v1/airman/airmen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof airman !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(airman !== undefined ? airman : {})
                : (airman || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes an airman record from the database
         * @summary Deletes an airman record
         * @param {string} id UUID id of the airman record to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAirman: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAirman.');
            }
            const localVarPath = `/v1/airman/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves single airman record
         * @summary Retrieves a single airman by UUID
         * @param {string} id UUID of the airman record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAirman: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAirman.');
            }
            const localVarPath = `/v1/airman/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all airmen records
         * @summary Retrieves all airmen
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAirman: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/airman`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing airman
         * @summary Updates an existing airman record
         * @param {string} id Airman record ID to update
         * @param {Airman} airman 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAirman: async (id: string, airman: Airman, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAirman.');
            }
            // verify required parameter 'airman' is not null or undefined
            if (airman === null || airman === undefined) {
                throw new RequiredError('airman','Required parameter airman was null or undefined when calling updateAirman.');
            }
            const localVarPath = `/v1/airman/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof airman !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(airman !== undefined ? airman : {})
                : (airman || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AirmanControllerApi - functional programming interface
 * @export
 */
export const AirmanControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new airman, ID field should be null for a new addition.
         * @summary Adds a new airman
         * @param {Airman} airman 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAirman(airman: Airman, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Airman>> {
            const localVarAxiosArgs = await AirmanControllerApiAxiosParamCreator(configuration).addAirman(airman, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adds one or more airmen entities - returns that same array of input airmen with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new airmen will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
         * @summary Adds one or more airmen entities
         * @param {Array<Airman>} airman 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAirmen(airman: Array<Airman>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Airman>> {
            const localVarAxiosArgs = await AirmanControllerApiAxiosParamCreator(configuration).addAirmen(airman, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes an airman record from the database
         * @summary Deletes an airman record
         * @param {string} id UUID id of the airman record to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAirman(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AirmanControllerApiAxiosParamCreator(configuration).deleteAirman(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves single airman record
         * @summary Retrieves a single airman by UUID
         * @param {string} id UUID of the airman record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAirman(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Airman>> {
            const localVarAxiosArgs = await AirmanControllerApiAxiosParamCreator(configuration).getAirman(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves all airmen records
         * @summary Retrieves all airmen
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAirman(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Airman>>> {
            const localVarAxiosArgs = await AirmanControllerApiAxiosParamCreator(configuration).getAllAirman(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an existing airman
         * @summary Updates an existing airman record
         * @param {string} id Airman record ID to update
         * @param {Airman} airman 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAirman(id: string, airman: Airman, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Airman>> {
            const localVarAxiosArgs = await AirmanControllerApiAxiosParamCreator(configuration).updateAirman(id, airman, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AirmanControllerApi - factory interface
 * @export
 */
export const AirmanControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adds a new airman, ID field should be null for a new addition.
         * @summary Adds a new airman
         * @param {Airman} airman 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAirman(airman: Airman, options?: any): AxiosPromise<Airman> {
            return AirmanControllerApiFp(configuration).addAirman(airman, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds one or more airmen entities - returns that same array of input airmen with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new airmen will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
         * @summary Adds one or more airmen entities
         * @param {Array<Airman>} airman 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAirmen(airman: Array<Airman>, options?: any): AxiosPromise<Airman> {
            return AirmanControllerApiFp(configuration).addAirmen(airman, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes an airman record from the database
         * @summary Deletes an airman record
         * @param {string} id UUID id of the airman record to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAirman(id: string, options?: any): AxiosPromise<void> {
            return AirmanControllerApiFp(configuration).deleteAirman(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves single airman record
         * @summary Retrieves a single airman by UUID
         * @param {string} id UUID of the airman record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAirman(id: string, options?: any): AxiosPromise<Airman> {
            return AirmanControllerApiFp(configuration).getAirman(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all airmen records
         * @summary Retrieves all airmen
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAirman(options?: any): AxiosPromise<Array<Airman>> {
            return AirmanControllerApiFp(configuration).getAllAirman(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing airman
         * @summary Updates an existing airman record
         * @param {string} id Airman record ID to update
         * @param {Airman} airman 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAirman(id: string, airman: Airman, options?: any): AxiosPromise<Airman> {
            return AirmanControllerApiFp(configuration).updateAirman(id, airman, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AirmanControllerApi - interface
 * @export
 * @interface AirmanControllerApi
 */
export interface AirmanControllerApiInterface {
    /**
     * Adds a new airman, ID field should be null for a new addition.
     * @summary Adds a new airman
     * @param {Airman} airman 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AirmanControllerApiInterface
     */
    addAirman(airman: Airman, options?: any): AxiosPromise<Airman>;

    /**
     * Adds one or more airmen entities - returns that same array of input airmen with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new airmen will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
     * @summary Adds one or more airmen entities
     * @param {Array<Airman>} airman 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AirmanControllerApiInterface
     */
    addAirmen(airman: Array<Airman>, options?: any): AxiosPromise<Airman>;

    /**
     * Removes an airman record from the database
     * @summary Deletes an airman record
     * @param {string} id UUID id of the airman record to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AirmanControllerApiInterface
     */
    deleteAirman(id: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves single airman record
     * @summary Retrieves a single airman by UUID
     * @param {string} id UUID of the airman record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AirmanControllerApiInterface
     */
    getAirman(id: string, options?: any): AxiosPromise<Airman>;

    /**
     * Retrieves all airmen records
     * @summary Retrieves all airmen
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AirmanControllerApiInterface
     */
    getAllAirman(options?: any): AxiosPromise<Array<Airman>>;

    /**
     * Updates an existing airman
     * @summary Updates an existing airman record
     * @param {string} id Airman record ID to update
     * @param {Airman} airman 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AirmanControllerApiInterface
     */
    updateAirman(id: string, airman: Airman, options?: any): AxiosPromise<Airman>;

}

/**
 * AirmanControllerApi - object-oriented interface
 * @export
 * @class AirmanControllerApi
 * @extends {BaseAPI}
 */
export class AirmanControllerApi extends BaseAPI implements AirmanControllerApiInterface {
    /**
     * Adds a new airman, ID field should be null for a new addition.
     * @summary Adds a new airman
     * @param {Airman} airman 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AirmanControllerApi
     */
    public addAirman(airman: Airman, options?: any) {
        return AirmanControllerApiFp(this.configuration).addAirman(airman, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds one or more airmen entities - returns that same array of input airmen with their assigned UUIDs. If the request does NOT return 201 (Created) because of an error (see other return codes), then no new airmen will have been committed to the database (if one entity fails, the entire operation fails). The return error message will list the offending UUID or other data that caused the error.
     * @summary Adds one or more airmen entities
     * @param {Array<Airman>} airman 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AirmanControllerApi
     */
    public addAirmen(airman: Array<Airman>, options?: any) {
        return AirmanControllerApiFp(this.configuration).addAirmen(airman, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes an airman record from the database
     * @summary Deletes an airman record
     * @param {string} id UUID id of the airman record to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AirmanControllerApi
     */
    public deleteAirman(id: string, options?: any) {
        return AirmanControllerApiFp(this.configuration).deleteAirman(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves single airman record
     * @summary Retrieves a single airman by UUID
     * @param {string} id UUID of the airman record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AirmanControllerApi
     */
    public getAirman(id: string, options?: any) {
        return AirmanControllerApiFp(this.configuration).getAirman(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all airmen records
     * @summary Retrieves all airmen
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AirmanControllerApi
     */
    public getAllAirman(options?: any) {
        return AirmanControllerApiFp(this.configuration).getAllAirman(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing airman
     * @summary Updates an existing airman record
     * @param {string} id Airman record ID to update
     * @param {Airman} airman 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AirmanControllerApi
     */
    public updateAirman(id: string, airman: Airman, options?: any) {
        return AirmanControllerApiFp(this.configuration).updateAirman(id, airman, options).then((request) => request(this.axios, this.basePath));
    }
}
